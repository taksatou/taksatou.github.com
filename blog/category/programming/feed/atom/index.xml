<?xml version="1.0" encoding="UTF-8"?>
<feed
  xmlns="http://www.w3.org/2005/Atom"
  xmlns:thr="http://purl.org/syndication/thread/1.0"
  xml:lang="en"
   >
  <title type="text">mojavy.com</title>
  <subtitle type="text"></subtitle>

  <updated>2013-06-28T20:45:36Z</updated>
  <generator uri="http://blogofile.com/">Blogofile</generator>

  <link rel="alternate" type="text/html" href="http://mojavy.com/blog" />
  <id>http://mojavy.com/blog/feed/atom/</id>
  <link rel="self" type="application/atom+xml" href="http://mojavy.com/blog/feed/atom/" />
  <entry>
    <author>
      <name></name>
      <uri>http://mojavy.com/blog</uri>
    </author>
    <title type="html"><![CDATA[GoroutineでConcurrentにエラトステネスの篩を計算する]]></title>
    <link rel="alternate" type="text/html" href="http://mojavy.com/blog/2013/06/28/goroutine-concurrent-sieve-of-eratosthenes/" />
    <id>http://mojavy.com/blog/2013/06/28/goroutine-concurrent-sieve-of-eratosthenes/</id>
    <updated>2013-06-28T20:45:36Z</updated>
    <published>2013-06-28T20:45:36Z</published>
    <category scheme="http://mojavy.com/blog" term="go" />
    <category scheme="http://mojavy.com/blog" term="programming" />
    <summary type="html"><![CDATA[GoroutineでConcurrentにエラトステネスの篩を計算する]]></summary>
    <content type="html" xml:base="http://mojavy.com/blog/2013/06/28/goroutine-concurrent-sieve-of-eratosthenes/"><![CDATA[<p><img alt="gopher" src="/images/gopherbw-250.png" /> </p>
<p>Goの練習がてら<a href="http://ja.wikipedia.org/wiki/%E3%82%A8%E3%83%A9%E3%83%88%E3%82%B9%E3%83%86%E3%83%8D%E3%82%B9%E3%81%AE%E7%AF%A9">エラトステネスの篩</a> を実装してみた。</p>
<p><a href="http://projecteuler.net/problem=7">Project Eulerにちょうどいい問題(10001st prime)</a> があったので、まずは単なるクロージャで書いてみる。<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> </p>
<div class="pygments_murphy"><pre><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
<span class="p">)</span>

<span class="k">var</span> <span class="p">(</span>
    <span class="n">lim</span> <span class="p">=</span> <span class="mi">10000000</span>
    <span class="n">tgt</span> <span class="p">=</span> <span class="mi">100001</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">GetPrimes</span><span class="p">()</span> <span class="k">func</span><span class="p">()</span> <span class="nb">int</span> <span class="p">{</span>
    <span class="n">sieve</span> <span class="p">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="n">bool</span><span class="p">,</span> <span class="n">lim</span><span class="p">)</span>
    <span class="n">p</span> <span class="p">:=</span> <span class="mi">2</span>

    <span class="k">return</span> <span class="k">func</span><span class="p">()</span> <span class="nb">int</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">i</span> <span class="p">:=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="p">*</span> <span class="n">p</span> <span class="p">&lt;</span> <span class="n">lim</span><span class="p">;</span> <span class="n">i</span><span class="p">++</span> <span class="p">{</span>
            <span class="n">sieve</span><span class="p">[</span><span class="n">i</span><span class="p">*</span><span class="n">p</span><span class="p">]</span> <span class="p">=</span> <span class="n">true</span>
        <span class="p">}</span>
        <span class="n">ret</span> <span class="p">:=</span> <span class="n">p</span>
        <span class="k">for</span> <span class="n">i</span> <span class="p">:=</span> <span class="n">p</span> <span class="p">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">lim</span><span class="p">;</span> <span class="n">i</span><span class="p">++</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">sieve</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">==</span> <span class="n">false</span> <span class="p">{</span>
                <span class="n">p</span> <span class="p">=</span> <span class="n">i</span>
                <span class="k">break</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">ret</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">p</span> <span class="p">:=</span> <span class="n">GetPrimes</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="p">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">tgt</span><span class="p">;</span> <span class="n">i</span><span class="p">++</span> <span class="p">{</span> <span class="n">p</span><span class="p">()</span> <span class="p">}</span>
    <span class="n">fmt</span><span class="p">.</span><span class="n">Println</span><span class="p">(</span><span class="s">&quot;&gt;&gt; &quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">())</span>
<span class="p">}</span>
</pre></div>

<p>これをGoroutineで書き換えるのは簡単で、返り値のかわりにチャネルをつかうようにするだけ。</p>
<div class="pygments_murphy"><pre><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="k">var</span> <span class="p">(</span>
    <span class="n">lim</span> <span class="p">=</span> <span class="mi">10000000</span>
    <span class="n">tgt</span> <span class="p">=</span> <span class="mi">100001</span>
    <span class="n">buf</span> <span class="p">=</span> <span class="mi">100</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">GetPrimes2</span><span class="p">(</span><span class="n">lim</span> <span class="nb">int</span><span class="p">)</span> <span class="k">chan</span> <span class="nb">int</span> <span class="p">{</span>
    <span class="n">sieve</span> <span class="p">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="n">bool</span><span class="p">,</span> <span class="n">lim</span><span class="p">)</span>
    <span class="n">primes</span> <span class="p">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="nb">int</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span>
    <span class="n">p</span> <span class="p">:=</span> <span class="mi">2</span>

    <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">{</span>
            <span class="k">for</span> <span class="n">i</span> <span class="p">:=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="p">*</span> <span class="n">p</span> <span class="p">&lt;</span> <span class="n">lim</span><span class="p">;</span> <span class="n">i</span><span class="p">++</span> <span class="p">{</span>
                <span class="n">sieve</span><span class="p">[</span><span class="n">i</span><span class="p">*</span><span class="n">p</span><span class="p">]</span> <span class="p">=</span> <span class="n">true</span>
            <span class="p">}</span>
            <span class="n">primes</span> <span class="p">&lt;-</span> <span class="n">p</span>
            <span class="k">for</span> <span class="n">i</span> <span class="p">:=</span> <span class="n">p</span> <span class="p">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">lim</span><span class="p">;</span> <span class="n">i</span><span class="p">++</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">sieve</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">==</span> <span class="n">false</span> <span class="p">{</span>
                    <span class="n">p</span> <span class="p">=</span> <span class="n">i</span>
                    <span class="k">break</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}()</span>
    <span class="k">return</span> <span class="n">primes</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">c</span> <span class="p">:=</span> <span class="n">GetPrimes2</span><span class="p">(</span><span class="n">lim</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="p">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">tgt</span><span class="p">;</span> <span class="n">i</span><span class="p">++</span> <span class="p">{</span> <span class="p">&lt;-</span><span class="n">c</span> <span class="p">}</span>
    <span class="n">fmt</span><span class="p">.</span><span class="n">Println</span><span class="p">(</span><span class="s">&quot;&gt;&gt; &quot;</span><span class="p">,</span> <span class="p">&lt;-</span><span class="n">c</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>

<p>pが素数のときp〜2*pの区間に少なくとも一つの素数が存在する、という前提<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> をつかって↑を並列化させた。<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> </p>
<div class="pygments_murphy"><pre><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;runtime&quot;</span>
<span class="p">)</span>

<span class="k">var</span> <span class="p">(</span>
    <span class="n">lim</span> <span class="p">=</span> <span class="mi">10000000</span>
    <span class="n">tgt</span> <span class="p">=</span> <span class="mi">100001</span>
    <span class="n">buf</span> <span class="p">=</span> <span class="mi">100</span>
    <span class="n">concurrency</span> <span class="p">=</span> <span class="mi">8</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">GetPrimes3</span><span class="p">()</span> <span class="k">chan</span> <span class="nb">int</span> <span class="p">{</span>
    <span class="n">sieve</span> <span class="p">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="n">bool</span><span class="p">,</span> <span class="n">lim</span><span class="p">)</span>
    <span class="n">primes</span> <span class="p">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="nb">int</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span>
    <span class="n">primes2</span> <span class="p">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="nb">int</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span>
    <span class="n">wait_next</span> <span class="p">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="n">bool</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span>

    <span class="n">primes</span> <span class="p">&lt;-</span> <span class="mi">2</span>
    <span class="n">primes2</span> <span class="p">&lt;-</span> <span class="mi">2</span>

    <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">p</span> <span class="p">:=</span> <span class="mi">2</span>
        <span class="k">for</span> <span class="p">{</span>
            <span class="p">&lt;-</span> <span class="n">wait_next</span>
            <span class="k">for</span> <span class="n">i</span> <span class="p">:=</span> <span class="n">p</span> <span class="p">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">lim</span><span class="p">;</span> <span class="n">i</span><span class="p">++</span> <span class="p">{</span>
                <span class="k">if</span> <span class="n">sieve</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">==</span> <span class="n">false</span> <span class="p">{</span>
                    <span class="n">primes</span> <span class="p">&lt;-</span> <span class="n">p</span>
                    <span class="n">primes2</span> <span class="p">&lt;-</span> <span class="n">p</span>
                    <span class="n">p</span> <span class="p">=</span> <span class="n">i</span>
                    <span class="k">break</span>
                <span class="p">}</span>
            <span class="p">}</span>

        <span class="p">}</span>
    <span class="p">}()</span>

    <span class="k">for</span> <span class="n">n</span> <span class="p">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="p">&lt;</span> <span class="n">concurrency</span><span class="p">;</span> <span class="n">n</span><span class="p">++</span> <span class="p">{</span>
        <span class="k">go</span> <span class="k">func</span><span class="p">(</span><span class="n">id</span> <span class="nb">int</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">{</span>
                <span class="n">p</span> <span class="p">:=</span> <span class="p">&lt;-</span> <span class="n">primes2</span>
                <span class="n">sieve</span><span class="p">[</span><span class="mi">2</span><span class="p">*</span><span class="n">p</span><span class="p">]</span> <span class="p">=</span> <span class="n">true</span>
                <span class="n">wait_next</span> <span class="p">&lt;-</span> <span class="n">true</span>
                <span class="k">for</span> <span class="n">i</span> <span class="p">:=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span> <span class="p">*</span> <span class="n">p</span> <span class="p">&lt;</span> <span class="n">lim</span><span class="p">;</span> <span class="n">i</span><span class="p">++</span> <span class="p">{</span>
                    <span class="n">sieve</span><span class="p">[</span><span class="n">i</span><span class="p">*</span><span class="n">p</span><span class="p">]</span> <span class="p">=</span> <span class="n">true</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}(</span><span class="n">n</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">primes</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">runtime</span><span class="p">.</span><span class="n">GOMAXPROCS</span><span class="p">(</span><span class="n">concurrency</span><span class="p">)</span>
    <span class="n">c</span> <span class="p">:=</span> <span class="n">GetPrimes3</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="p">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">tgt</span><span class="p">;</span> <span class="n">i</span><span class="p">++</span> <span class="p">{</span> <span class="p">&lt;-</span><span class="n">c</span> <span class="p">}</span>
    <span class="n">fmt</span><span class="p">.</span><span class="n">Println</span><span class="p">(</span><span class="s">&quot;&gt;&gt; &quot;</span><span class="p">,</span> <span class="p">&lt;-</span><span class="n">c</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>

<p>篩をうめるときは最初の数(ある素数の2倍の数)をうめた時点で次の素数が決定できるのでそこのループを並列化できるかと思ったけど、残念ながら速度は体感でわかるほど遅くなってしまった。<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup> </p>
<p>今度スケジューラとかgoroutineまわりのソースを読んでみようと思う。</p>
<h4 id="_1">参考</h4>
<ul>
<li><a href="https://gist.github.com/methane/5377227#file-goscheduler-md">https://gist.github.com/methane/5377227#file-goscheduler-md</a> </li>
</ul>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>ある程度処理に時間がかかるように定数は適当にかえてます&#160;<a href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p><a href="http://ja.wikipedia.org/wiki/%E3%83%99%E3%83%AB%E3%83%88%E3%83%A9%E3%83%B3%E3%81%AE%E4%BB%AE%E8%AA%AC">チェビシェフの定理</a>&#160;<a href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:3">
<p>呼び出し側に素数を渡すためのチャネルと篩をうめるgoroutineに素数を渡すためのチャネルの2本をつかってるのがださい&#160;<a href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:4">
<p>8コアのlinuxマシンで実行しています&#160;<a href="#fnref:4" rev="footnote" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
</ol>
</div>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://mojavy.com/blog</uri>
    </author>
    <title type="html"><![CDATA[The P Convention]]></title>
    <link rel="alternate" type="text/html" href="http://mojavy.com/blog/2013/02/24/the-p-convention/" />
    <id>http://mojavy.com/blog/2013/02/24/the-p-convention/</id>
    <updated>2013-02-24T14:42:00Z</updated>
    <published>2013-02-24T14:42:00Z</published>
    <category scheme="http://mojavy.com/blog" term="lisp" />
    <category scheme="http://mojavy.com/blog" term="programming" />
    <summary type="html"><![CDATA[The P Convention]]></summary>
    <content type="html" xml:base="http://mojavy.com/blog/2013/02/24/the-p-convention/"><![CDATA[<p><img alt="lisp" src="/images/lisplogo_fancy_128.png" /></p>
<p>Lispには'p'という接尾辞がつく名前の関数があるが、この'p'はpredicateのこと。</p>
<p><a href="http://catb.org/jargon/html/p-convention.html">The -P Convention</a></p>
<p>ところが、HaskellやOCamlにも'p'という接尾辞がつく関数があって、そちらはprimeの意味で使うらしい。
シングルクオート(ダッシュ)記号は英語だとprimeというので、例えば<code>foo'</code>という名前の関数は<code>foo</code>という名前のヘルパー関数的なもの、ということになる。</p>
<p><a href="http://stackoverflow.com/questions/5279286/foop-a-naming-convention-its-a-helper-recursive-function-for-foo-what-do">“foop”: a naming convention? It's a helper recursive function for “foo”; what does the suffix “p” mean?</a></p>
<p>ちなみに、OCamlだとシングルクオートが識別子につかえるのでfoo'という名前の関数も結構あるらしい。</p>
<p>まぎらわしい、かと思ったけど使う文脈が違うし意外とそうでもないか。</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://mojavy.com/blog</uri>
    </author>
    <title type="html"><![CDATA[人気プログラミング言語ランキング(stackoverflow調べ)]]></title>
    <link rel="alternate" type="text/html" href="http://mojavy.com/blog/2013/02/05/popular-programming-languages/" />
    <id>http://mojavy.com/blog/2013/02/05/popular-programming-languages/</id>
    <updated>2013-02-05T23:00:00Z</updated>
    <published>2013-02-05T23:00:00Z</published>
    <category scheme="http://mojavy.com/blog" term="programming" />
    <summary type="html"><![CDATA[人気プログラミング言語ランキング(stackoverflow調べ)]]></summary>
    <content type="html" xml:base="http://mojavy.com/blog/2013/02/05/popular-programming-languages/"><![CDATA[<p><img alt="stack" src="/images/stackoverflow-200.png" /></p>
<p>なんとなく気になったのでstackoverflowのでの人気プログラミング言語ランキングをつくってみました。(2013-02-05現在)</p>
<div class="pygments_murphy"><pre>1.   c#              411382pt
2.   java            361120pt
3.   php             337941pt
4.   javascript      321791pt
5.   c++             175790pt
6.   python          160796pt
7.   html            145373pt
8.   objective-c     119891pt
9.   sql             115147pt
10.  css             113039pt
11.  c               83501pt
12.  ruby            64350pt
13.  xml             56444pt
14.  regex           51670pt
15.  vb.net          41260pt
16.  html5           27217pt
17.  linq            26200pt
18.  actionscript-3  24286pt
19.  perl            24092pt
20.  r               23256pt
21.  delphi          18866pt
22.  tsql            18119pt
23.  matlab          15289pt
24.  xaml            14115pt
25.  scala           13444pt
26.  vba             12300pt
27.  css3            11564pt
28.  xslt            11032pt
29.  haskell         9827pt
30.  assembly        7580pt
31.  razor           7385pt
32.  actionscript    6440pt
33.  excel-vba       6309pt
34.  groovy          5551pt
35.  vbscript        4926pt
36.  c++11           4894pt
37.  vb6             4886pt
38.  xhtml           4675pt
39.  plsql           4548pt
40.  svg             4540pt
41.  f#              4341pt
42.  python-3.x      4229pt
43.  awk             3481pt
44.  wsdl            3249pt
45.  lua             3183pt
46.  erlang          3077pt
47.  coffeescript    2754pt
48.  c#-3.0          2615pt
49.  latex           2570pt
50.  lisp            2395pt
51.  mathematica     2395pt
52.  prolog          2317pt
53.  scheme          2199pt
54.  uml             2093pt
55.  applescript     2092pt

-- 次点

go         1648pt
ocaml      1329pt
d          877pt
</pre></div>

<h3 id="_1">補足</h3>
<ul>
<li>stackoverflow APIを利用して調べました。stackoverflow公式のものではありません。</li>
<li>ランキングは質問につけられたタグの件数順です。</li>
<li>プログラミング言語のタグは、tag infoのエントリに/language/i がマッチするかどうかで抽出し、明らかにプログラミング言語じゃないものは手動で適当に除外しました。</li>
<li>マークアップ言語とかバージョン違いで複数ある言語とか微妙なのはそのまま残しました。</li>
<li>次点以下の言語は、apiをしばらくクロールしてもでてこなかった言語のうち思いついたものを手動でしらべました。</li>
</ul>
<h3 id="_2">所感</h3>
<p>C#が1位なのはちょっと意外でしたがそれ以外は大体イメージ通りでした。
質問が多い順でもあるので、下位にある言語は質問が少なくて逆にイケてると言えなくもないですね。</p>
<p>D言語すばらしい。</p>
<p>ともあれ、stackoverflowのAPIは結構充実してるので色々遊べそうです。</p>
<ul>
<li><a href="http://api.stackoverflow.com/1.0/usage">http://api.stackoverflow.com/1.0/usage</a></li>
</ul>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://mojavy.com/blog</uri>
    </author>
    <title type="html"><![CDATA[C言語の文字列初期化について]]></title>
    <link rel="alternate" type="text/html" href="http://mojavy.com/blog/2013/01/21/c-string-initialization/" />
    <id>http://mojavy.com/blog/2013/01/21/c-string-initialization/</id>
    <updated>2013-01-21T20:00:00Z</updated>
    <published>2013-01-21T20:00:00Z</published>
    <category scheme="http://mojavy.com/blog" term="C" />
    <category scheme="http://mojavy.com/blog" term="programming" />
    <summary type="html"><![CDATA[C言語の文字列初期化について]]></summary>
    <content type="html" xml:base="http://mojavy.com/blog/2013/01/21/c-string-initialization/"><![CDATA[<p>なんとなく気になったので以下ひとりごと。</p>
<hr>

<p>Cで文字列を初期化するときは以下のように書く。</p>
<div class="pygments_murphy"><pre>char str[] = &quot;xyz&quot;;
</pre></div>

<p>こう書けばNULL終わりのchar配列としてスタックに格納してくれるので、以下のように書くのと同じことになる。</p>
<div class="pygments_murphy"><pre>char str1[4] = &quot;xyz&quot;;
char str2[4] = {&#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;\0&#39;};
</pre></div>

<p>文字列はcharのポインタで扱うからといって、</p>
<div class="pygments_murphy"><pre>char *str = &quot;xyz&quot;;
</pre></div>

<p>のように書くと違う意味になる。
こう書くと"xyz"が格納されているアドレスでポインタを初期化する。文字列リテラルで宣言したデータが格納される領域は通常はread onlyなので<code>*str='X'</code>などとするとセグフォするが、通常の代入と同じ意味なので違和感はない。</p>
<p>でも、<code>char str[] = "xyz";</code> のほうはは冷静に考えると気持ち悪い。初期化と代入は違うといってしまえばそれまでだけど、この式だけみても予備知識がないとなにがおこるのかわからないと思う。</p>
<p>以下のような挙動も合理的とは思えない。そもそもCに配列なんて必要なかったのではないか。</p>
<div class="pygments_murphy"><pre>void f1(char s[]) {
    /* 意味はないけどエラーでもない */
    s = &quot;baz&quot;;
}

void f2(void) {
    char s[] = &quot;foo&quot;;
    /* これはエラー */
    /* s = &quot;bar&quot;; */
}
</pre></div>

<p>などということを今更ながら考えて悶々としていたのだけど、結局のところこういう類の便利機能は欲しくなってくるわけで、便利さのために不合理を許容するとなるとこのあたりが妥当な落とし所のような気もしてきた。</p>
<p>まとめ：プログラミング言語を考える人はすごい</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://mojavy.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Common Lisp練習 - CodeChef : TSORT]]></title>
    <link rel="alternate" type="text/html" href="http://mojavy.com/blog/2012/10/24/cl-practice/" />
    <id>http://mojavy.com/blog/2012/10/24/cl-practice/</id>
    <updated>2012-10-24T18:00:00Z</updated>
    <published>2012-10-24T18:00:00Z</published>
    <category scheme="http://mojavy.com/blog" term="programming" />
    <category scheme="http://mojavy.com/blog" term="common lisp" />
    <summary type="html"><![CDATA[Common Lisp練習 - CodeChef : TSORT]]></summary>
    <content type="html" xml:base="http://mojavy.com/blog/2012/10/24/cl-practice/"><![CDATA[<p><img alt="codechef" src="/images/codechef-logo.png" /></p>
<p>Common Lispの練習にCodeChefの↓の練習問題をやってみた。</p>
<p><a href="http://www.codechef.com/problems/TSORT">http://www.codechef.com/problems/TSORT</a></p>
<p>問題自体は全然難しくないけど、Common Lispで解こうとしたらTime Limit Exceededでおちてしまった。</p>
<p>最初は以下のように書いて、</p>
<div class="pygments_murphy"><pre>(let ((_n (parse-integer (read-line)))
      (lis ()))
  (dotimes (i _n)
    (push (parse-integer (read-line)) lis))
  (setf lis (sort lis #&#39;(lambda (x y) (&lt; x y))))
  (dolist (x lis) (format t &quot;~a~%&quot; x)))
</pre></div>

<p>以下の用にして時間を測ったところ</p>
<div class="pygments_murphy"><pre><span class="nv">$ </span><span class="nb">time </span>ruby -e <span class="s1">&#39;n=1000000;puts n; n.times{puts (rand * 10000000).to_i}&#39;</span> | sbcl --script turbosort.cl &gt; /dev/null
ruby -e <span class="s1">&#39;n=1000000;puts n; n.times{puts (rand * 10000000).to_i}&#39;</span>  1.19s user 0.01s system 91% cpu 1.311 total
sbcl --script turbosort.cl &gt; /dev/null  3.42s user 0.43s system 97% cpu 3.938 total
</pre></div>

<p>ローカルだと3.42s程度だった。codechef上での制限は5secなのでセーフかと思ったけどTime Limit Exceededだった。</p>
<p>そこで、vectorを使うように改良</p>
<div class="pygments_murphy"><pre>(let* ((_n (parse-integer (read-line)))
       (lis (make-array _n :fill-pointer 0)))
  (dotimes (i _n)
    (vector-push (parse-integer (read-line)) lis))
  (setf lis (sort lis #&#39;(lambda (x y) (&lt; x y))))
  (loop for i across lis do (format t &quot;~a~%&quot; i)))
</pre></div>

<div class="pygments_murphy"><pre><span class="nv">$ </span><span class="nb">time </span>ruby -e <span class="s1">&#39;n=1000000;puts n; n.times{puts (rand * 10000000).to_i}&#39;</span> | sbcl --script turbosort.cl &gt; /dev/null
ruby -e <span class="s1">&#39;n=1000000;puts n; n.times{puts (rand * 10000000).to_i}&#39;</span>  1.21s user 0.01s system 94% cpu 1.289 total
sbcl --script turbosort.cl &gt; /dev/null  2.64s user 0.44s system 98% cpu 3.137 total
</pre></div>

<p>若干改善されたが、まだTime Limit Exceededだった。</p>
<p>read-sequenceで読み込んだほうが早いかと思って以下のように書いてみた。</p>
<div class="pygments_murphy"><pre>(defun parse-input (str)
  (loop
     for i = 0 then (+ 1 j)
     as j = (position #\Newline str :start i)
     as k = (parse-integer (subseq str i j) :junk-allowed t)
     if (not (null k))
     collect k
     while j))

(let* ((_n (parse-integer (read-line)))
       (lis (make-array (* _n 20) :element-type &#39;character))
       (nums ())
       )
  (read-sequence lis *standard-input*)
  (setf nums (sort (parse-input lis) #&#39;(lambda (x y) (&lt; x y))))
  (loop for i in nums do (format t &quot;~a~%&quot; i)))
</pre></div>

<div class="pygments_murphy"><pre><span class="nv">$ </span><span class="nb">time </span>ruby -e <span class="s1">&#39;n=1000000;puts n; n.times{puts (rand * 10000000).to_i}&#39;</span> | sbcl --script turbosort.cl &gt; /dev/null
ruby -e <span class="s1">&#39;n=1000000;puts n; n.times{puts (rand * 10000000).to_i}&#39;</span>  1.13s user 0.01s system 97% cpu 1.159 total
sbcl --script turbosort.cl &gt; /dev/null  3.67s user 0.48s system 96% cpu 4.297 total
</pre></div>

<p>残念ながら逆に遅くなってしまった。parse-inputの部分で60%くらい時間がかかっていた。
あと、<code>#'(lambda (x y) (&lt; x y))</code>の部分を <code>#'&lt;</code>にするとなぜか遅くなる。</p>
<p><a href="http://www.codechef.com/status/TSORT?language=31&amp;status=All&amp;handle=&amp;sort_by=All&amp;sorting_order=asc&amp;Submit=GO">まだ誰もlispではパスしてない模様。</a>こういうのをもっと高速に書く方法あるのだろうか。</p>
<p>ちなみにCだと余裕。ローカルだと0.2秒くらいだけどリモートでは3秒くらいかかってた。そもそもCodeChefの実行環境がしょぼすぎる疑惑が。。</p>
<div class="pygments_murphy"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>

<span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">j</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">fgets</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="n">stdin</span><span class="p">));</span>

    <span class="kt">int</span> <span class="n">lis</span><span class="p">[</span><span class="n">num</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">lis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">fgets</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="n">stdin</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="n">qsort</span><span class="p">(</span><span class="n">lis</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="n">f</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">lis</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
</pre></div>

<div class="pygments_murphy"><pre><span class="nv">$ </span><span class="nb">time </span>ruby -e <span class="s1">&#39;n=1000000;puts n; n.times{puts (rand * 10000000).to_i}&#39;</span> | ./a.out &gt; /dev/null
ruby -e <span class="s1">&#39;n=1000000;puts n; n.times{puts (rand * 10000000).to_i}&#39;</span>  0.99s user 0.01s system 99% cpu 1.006 total
./a.out &gt; /dev/null  0.18s user 0.01s system 17% cpu 1.116 total
</pre></div>]]></content>
  </entry>
</feed>
