<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <title>mojavy.com</title>
    <link>http://mojavy.com/blog</link>
    <description></description>
    <pubDate>Mon, 02 Mar 2015 20:55:43 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    <item>
      <title>Phabricatorを使ったワークフローについて</title>
      <link>http://mojavy.com/blog/2015/03/02/phabricator-workflow/</link>
      <pubDate>Mon, 02 Mar 2015 20:55:43 JST</pubDate>
      <category><![CDATA[tools]]></category>
      <category><![CDATA[programming]]></category>
      <category><![CDATA[project management]]></category>
      <guid isPermaLink="true">http://mojavy.com/blog/2015/03/02/phabricator-workflow/</guid>
      <description>Phabricatorを使ったワークフローについて</description>
      <content:encoded><![CDATA[<p><img alt="phabricator" src="/images/phabricator-logo.png" /> </p>
<p>最近 <a href="http://phabricator.org/">Phabricator</a> を使ったワークフローを試しています。FacebookやDropboxをはじめとして海外では割と良く使われているようですが、あまり国内には情報がないようなのでまとめておきます。</p>
<h2 id="phabricator">Phabricatorでできること</h2>
<p>Phabricatorはコードレビューがメイン機能のようですが、それに留まらずソフトウェアの開発で必要なものがワンストップでまとまったプロジェクト管理ツールになっています。</p>
<p>メニューのネーミングが独特でとっつきづらいですが、主に以下のような機能があります。</p>
<ul>
<li><code>Differential</code>: pre push型のコードレビュー</li>
<li><code>Audit</code>: post push型のコードレビュー</li>
<li><code>Maniphest</code>: タスクとバグの管理</li>
<li><code>Diffusion</code>: リポジトリの管理</li>
<li><code>Harald</code>: commitやタスクの更新イベントにフックして起動する処理の管理</li>
<li><code>Phriction</code>: Wiki</li>
</ul>
<p>また、<a href="https://github.com/phacility/arcanist">arcanist</a> というコマンドラインから操作するためのツールも別途提供されており、開発のワークフローも含めた統合が意図されているようです。</p>
<h2 id="_1">セットアップ</h2>
<p>docker環境があるなら <code>docker run yesnault/docker-phabricator</code> ですぐ試せます。</p>
<p><a href="https://registry.hub.docker.com/u/yesnault/docker-phabricator/">https://registry.hub.docker.com/u/yesnault/docker-phabricator/</a> </p>
<p>ただし、上記dockerfileから構築したコンテナはデフォルトだとメールは外部に送信できない設定になっています。admin以外のユーザ登録ではメールアドレス認証が必要なので、<code>docker exec -it &lt;container_id&gt; bash</code> でコンテナに入ってメール設定を適宜修正して下さい。</p>
<p>dockerを使わずに普通にインストールする場合は <a href="https://secure.phabricator.com/book/phabricator/article/installation_guide/">https://secure.phabricator.com/book/phabricator/article/installation_guide/</a> を参照してください。</p>
<p>起動直後は色々設定を聞かれますが、特につまるようなところはないので省略します。</p>
<h2 id="phabricator_1">Phabricatorでのコードレビュー</h2>
<h3 id="pre-push-differential">pre-push型のコードレビュー (Differential)</h3>
<p>pre-push型のコードレビューは、フロー的にはGithubでのPull Requestに似ていますが、レビュー対象のコードをpushするのではなく、パッチを送る点が異なります。Phabricatorでは以下のようなフローで作業することになります。</p>
<ol>
<li>コードを修正した人(author)は、レビュワー(reviewer)を指定して変更内容をDifferentialに送る</li>
<li>reviewerは通知を受けてレビューをする</li>
<li>reviwerがacceptしたら、authorはupstreamにpushする</li>
</ol>
<p>diffをPhabricatorにコピペして登録することもできますが、基本的にはarcanist経由で作業することになります。</p>
<p>PhabricatorのUser Guideには<a href="https://secure.phabricator.com/book/phabricator/article/reviews_vs_audit/">Differentialの良さ</a> が長々と書かれてますが、実際のところ、長所として挙げられている項目はどれもPull Requestベースでも達成できます。
ただ、Defferentialとarcanistを使えば簡単にレビュー依頼が投げられるので、開発者が自発的に適切な粒度でレビュー依頼する助けにはなりそうです。</p>
<h3 id="post-push-audit">post-push型のコードレビュー (Audit)</h3>
<p>Differentialではレビューが完了するまでpushを待つ必要がありますが、Auditはレビューを待たずにpushしてその後にレビューを実施するための機能です。</p>
<p>例えば、急いでリリースする必要がある場合でも、Auditを用いてあとからレビューすることができます。このときに問題が見つかれば<code>Problem Commits</code>というフラグをたてておいてタスクに積む、というような使い方になるようです。</p>
<p><code>Harald</code>という機能を使えば特定の条件に合致するcommit(例えば変更が大きい、Differentialでレビューされていない、等)があった場合は自動的にAuditを生成させることもできます。</p>
<p>Auditをpull requestのように使うこともできますが、推奨はされていないようです。</p>
<h2 id="_2">所感</h2>
<p>もし開発管理のためにredmineやjiraをつかっているのであればPhabricatorは良い代替になりそうです。開発者向けに特化してる分、プロジェクトのタスクやバグ管理がソースコードとうまく統合されていて、ダッシュボードも柔軟にカスタマイズできます。githubのissueに不満を感じている人もPhabricatorのワークフローは試してみる価値があると思います。</p>
<p>レビューツール単体としてみると、(Differentialをつかうなら)開発者にarcanistの導入をしてもらう必要がある分、Pull Requestの手軽さに比べるとやや煩雑に感じました。既にPull Requestベースの開発が定着していて、単によりよいレビューツールを探しているのであれば<a href="https://code.google.com/p/gerrit/">Gerrit</a> 等のほうが導入しやすいかもしれません。</p>
<h2 id="_3">その他</h2>
<ul>
<li><a href="https://showoff.phab.io/">https://showoff.phab.io/</a> でデモPhabricatorが使えるので一通り試せます。</li>
<li>デフォルトではかなりの頻度でリポジトリに対してポーリングしに行きます。負荷をかけ過ぎないように注意が必要です。</li>
<li>Phabricator自体もそれなりの性能のマシンが必要です。環境によってはworker数を減らしたりmysqlのメモリサイズを調整しておく必要があります。</li>
</ul>
<h2 id="_4">参考</h2>
<ul>
<li><a href="https://secure.phabricator.com/book/phabricator/article/differential/">https://secure.phabricator.com/book/phabricator/article/differential/</a> </li>
<li><a href="https://secure.phabricator.com/book/phabricator/article/audit/">https://secure.phabricator.com/book/phabricator/article/audit/</a> </li>
<li><a href="https://secure.phabricator.com/book/phabricator/article/reviews_vs_audit/">https://secure.phabricator.com/book/phabricator/article/reviews_vs_audit/</a> </li>
</ul>]]></content:encoded>
    </item>
    <item>
      <title>C++のdreaded diamondについて</title>
      <link>http://mojavy.com/blog/2014/07/09/cpp-dreaded-diamond/</link>
      <pubDate>Wed, 09 Jul 2014 21:56:32 JST</pubDate>
      <category><![CDATA[programming]]></category>
      <category><![CDATA[c++]]></category>
      <guid isPermaLink="true">http://mojavy.com/blog/2014/07/09/cpp-dreaded-diamond/</guid>
      <description>C++のdreaded diamondについて</description>
      <content:encoded><![CDATA[<p>以下のようなダイアモンド継承をしたときに発生する問題のことを<code>dreaded diamond</code>と呼ぶらしい。</p>
<div class="pygments_borland"><pre>    Base
    /  \
   D1  D2
    \  /
     D3
</pre></div>

<p>例えば以下のようなクラスではアップキャストをするときやBaseクラスのメンバにアクセスするときに曖昧性が生じる。</p>
<div class="pygments_borland"><pre><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Base</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">D1</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">D1</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">D2</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">D2</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">D3</span> <span class="o">:</span> <span class="k">public</span> <span class="n">D1</span><span class="p">,</span> <span class="k">public</span> <span class="n">D2</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">D3</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>
</pre></div>

<p>以下のようなコードをコンパイルしようとしてもエラーになる。</p>
<div class="pygments_borland"><pre><span class="kt">void</span> <span class="n">f1</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">D3</span> <span class="n">d3</span><span class="p">;</span>
    <span class="n">Base</span> <span class="o">&amp;</span><span class="n">base</span> <span class="o">=</span> <span class="n">d3</span><span class="p">;</span>
    <span class="n">d3</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<div class="pygments_borland"><pre>      ambiguous conversion from derived class &#39;D3&#39; to base class &#39;Base&#39;:
    class D3 -&gt; class D1 -&gt; class Base
    class D3 -&gt; class D2 -&gt; class Base
    Base &amp;base = d3;
                 ^~

      non-static member &#39;data&#39; found in multiple base-class subobjects of type &#39;Base&#39;:
    class D3 -&gt; class D1 -&gt; class Base
    class D3 -&gt; class D2 -&gt; class Base
    d3.data = 123;
       ^
</pre></div>

<p>これを回避するためには明示的に中継するクラスを指定してやる必要がある。</p>
<div class="pygments_borland"><pre><span class="kt">void</span> <span class="n">f2</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">D3</span> <span class="n">d3</span><span class="p">;</span>
    <span class="n">Base</span> <span class="o">&amp;</span><span class="n">base</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">D1</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">d3</span><span class="p">);</span>
    <span class="n">d3</span><span class="p">.</span><span class="n">D1</span><span class="o">::</span><span class="n">data</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
    <span class="n">d3</span><span class="p">.</span><span class="n">D2</span><span class="o">::</span><span class="n">data</span> <span class="o">=</span> <span class="mi">456</span><span class="p">;</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">d3</span><span class="p">.</span><span class="n">D1</span><span class="o">::</span><span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;,&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">d3</span><span class="p">.</span><span class="n">D2</span><span class="o">::</span><span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  <span class="c1">// =&gt; 123,456</span>
<span class="p">}</span>
</pre></div>

<p>でも普通は継承元にそれぞれの別々の親を持つのではなく、共通の1つだけを持っていてほしい。
それを解決するには仮想継承を使う。</p>
<div class="pygments_borland"><pre><span class="k">class</span> <span class="nc">D1</span> <span class="o">:</span> <span class="k">public</span> <span class="k">virtual</span> <span class="n">Base</span> <span class="p">{</span> <span class="cm">/* 省略 */</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">D2</span> <span class="o">:</span> <span class="k">public</span> <span class="k">virtual</span> <span class="n">Base</span> <span class="p">{</span> <span class="cm">/* 省略 */</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">D3</span> <span class="o">:</span> <span class="k">public</span> <span class="n">D1</span><span class="p">,</span> <span class="k">public</span> <span class="n">D2</span> <span class="p">{</span> <span class="cm">/* 省略 */</span> <span class="p">};</span>
</pre></div>

<p>このようにすればBaseクラスのインスタンスは1つだけになって曖昧性が解消される。</p>
<div class="pygments_borland"><pre><span class="kt">void</span> <span class="n">f3</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">D3</span> <span class="n">d3</span><span class="p">;</span>
    <span class="n">Base</span> <span class="o">&amp;</span><span class="n">base</span> <span class="o">=</span> <span class="n">d3</span><span class="p">;</span>
    <span class="n">d3</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">d3</span><span class="p">.</span><span class="n">D1</span><span class="o">::</span><span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;,&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">d3</span><span class="p">.</span><span class="n">D2</span><span class="o">::</span><span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  <span class="c1">// =&gt; 123,123</span>
<span class="p">}</span>
</pre></div>]]></content:encoded>
    </item>
    <item>
      <title>pthreadの取り消しポイント(cancellation point)についてのメモ</title>
      <link>http://mojavy.com/blog/2014/03/18/pthread-cancellation-point/</link>
      <pubDate>Tue, 18 Mar 2014 21:41:12 JST</pubDate>
      <category><![CDATA[unix]]></category>
      <category><![CDATA[programming]]></category>
      <guid isPermaLink="true">http://mojavy.com/blog/2014/03/18/pthread-cancellation-point/</guid>
      <description>pthreadの取り消しポイント(cancellation point)についてのメモ</description>
      <content:encoded><![CDATA[<p>cancellation pointsとは、スレッドのキャンセル種別が<code>deferred</code>のときに、そこに到達したときにはじめて実際にそのスレッドのキャンセル要求が処理されるような関数のこと。</p>
<p>POSIX.1では、基本的にはブロックするような関数がcancellation pointsであることが要求されている。</p>
<h2 id="_1">参考</h2>
<ul>
<li><a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/xsh_chap02_09.html">http://pubs.opengroup.org/onlinepubs/009695399/functions/xsh_chap02_09.html</a> </li>
<li><a href="http://linuxjm.sourceforge.jp/html/LDP_man-pages/man3/pthread_cancel.3.html">pthread_cancel(3)</a> </li>
</ul>]]></content:encoded>
    </item>
    <item>
      <title>malloc+memsetとcallocの違いについて</title>
      <link>http://mojavy.com/blog/2014/03/05/difference-between-malloc-and-calloc/</link>
      <pubDate>Wed, 05 Mar 2014 21:25:23 JST</pubDate>
      <category><![CDATA[os]]></category>
      <category><![CDATA[programming]]></category>
      <guid isPermaLink="true">http://mojavy.com/blog/2014/03/05/difference-between-malloc-and-calloc/</guid>
      <description>malloc+memsetとcallocの違いについて</description>
      <content:encoded><![CDATA[<p><code>malloc</code>と<code>calloc</code>の違いは、表面的には引数の数と<code>calloc</code>は確保した領域を0で初期化するという点くらいですが、以下のコードを大きな<code>n</code>で実行すると、今時のOSだと<code>malloc</code> + <code>memset</code>のほうが大幅に遅くなる可能性があります。</p>
<div class="pygments_borland"><pre><span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">type</span><span class="p">));</span>
<span class="n">memset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">type</span><span class="p">));</span>
</pre></div>

<div class="pygments_borland"><pre><span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">type</span><span class="p">));</span>
</pre></div>

<p>カーネルはセキュリティ上の理由からメモリを0で初期化してからユーザプロセスに渡します。</p>
<p>しかし、仮想メモリをサポートしたシステムでは、実際にそのメモリに書き込みが発生するまでカーネルはread onlyな領域を複数プロセスで共有させることができるため、既に初期化してあるページであればこの処理を省略できる場合があります。</p>
<p><code>brk</code>で拡張した領域は0で初期化されているので、<code>calloc</code>は新規確保した領域は初期化を省略することができ、結果的に<code>calloc</code>を実行したタイミングでは初期化が実際にはほとんど発生しない、ということがありえます。</p>
<p>一方<code>memset</code>の場合は実際にメモリへの書込みが発生する上、ページの共有もできなくなるためswapする可能性もあります。</p>
<p><br>
<br></p>
<p>ちなみに、(カーネルではなく)<code>calloc</code>自身が0初期化する処理と、<code>memset</code>の処理は微妙に違います。
なぜなら、<code>memset</code>は対象の領域がアラインされているかどうかについての情報なしに処理する必要があるので、境界部分は1byteずつやるしかありません。</p>
<p>じゃあ<code>memset</code>のほうが遅いのかというと、コンパイラによってはアラインされていることを推測できる場合もあったり、callocはライブラリ関数なので移植性のために最適化しにくかったりするので、結局のところ微妙です。</p>
<p>参考： <a href="http://stackoverflow.com/questions/2688466/why-mallocmemset-is-slower-than-calloc">http://stackoverflow.com/questions/2688466/why-mallocmemset-is-slower-than-calloc</a> </p>]]></content:encoded>
    </item>
    <item>
      <title>スレッドプールの実装方法について</title>
      <link>http://mojavy.com/blog/2014/03/03/implementing-thread-pool/</link>
      <pubDate>Mon, 03 Mar 2014 20:58:58 JST</pubDate>
      <category><![CDATA[unix]]></category>
      <category><![CDATA[programming]]></category>
      <guid isPermaLink="true">http://mojavy.com/blog/2014/03/03/implementing-thread-pool/</guid>
      <description>スレッドプールの実装方法について</description>
      <content:encoded><![CDATA[<p>スレッドプール(thread pool)を実装するには、暇なときはthreadを寝かせておいて必要なときに起こす、というイベント通知の仕組みが必要になる。
UnixでC/C++で実装するときはpthreadの条件変数を使うのが普通だと思われるが、適当なファイルディスクリプタをopenしておいてread等でブロックさせる方法でも実装できそう。</p>
<p>どのようなやり方が一般的なのか、いくつか有名どころのOSSの実装を調べてみた。</p>
<h3 id="libuv">libuvの場合</h3>
<p><a href="https://github.com/joyent/libuv">https://github.com/joyent/libuv</a> </p>
<p>単純に<code>pthread_cond_wait</code>をつかっている <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> </p>
<div class="pygments_borland"><pre><span class="k">static</span> <span class="kt">void</span> <span class="nf">worker</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">uv__work</span><span class="o">*</span> <span class="n">w</span><span class="p">;</span>
  <span class="n">QUEUE</span><span class="o">*</span> <span class="n">q</span><span class="p">;</span>

  <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">arg</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="n">uv_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">QUEUE_EMPTY</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="p">))</span>
      <span class="n">uv_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>

    <span class="n">q</span> <span class="o">=</span> <span class="n">QUEUE_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">q</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">exit_message</span><span class="p">)</span>
      <span class="n">uv_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">);</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="n">QUEUE_REMOVE</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
      <span class="n">QUEUE_INIT</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>  <span class="cm">/* Signal uv_cancel() that the work req is</span>
<span class="cm">                             executing. */</span>
    <span class="p">}</span>

    <span class="n">uv_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">q</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">exit_message</span><span class="p">)</span>
      <span class="k">break</span><span class="p">;</span>

    <span class="n">w</span> <span class="o">=</span> <span class="n">QUEUE_DATA</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uv__work</span><span class="p">,</span> <span class="n">wq</span><span class="p">);</span>
    <span class="n">w</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>

    <span class="n">uv_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">loop</span><span class="o">-&gt;</span><span class="n">wq_mutex</span><span class="p">);</span>
    <span class="n">w</span><span class="o">-&gt;</span><span class="n">work</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>  <span class="cm">/* Signal uv_cancel() that the work req is done</span>
<span class="cm">                        executing. */</span>
    <span class="n">QUEUE_INSERT_TAIL</span><span class="p">(</span><span class="o">&amp;</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">loop</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
    <span class="n">uv_async_send</span><span class="p">(</span><span class="o">&amp;</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">loop</span><span class="o">-&gt;</span><span class="n">wq_async</span><span class="p">);</span>
    <span class="n">uv_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">loop</span><span class="o">-&gt;</span><span class="n">wq_mutex</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<h3 id="boostasio">Boost.Asioの場合</h3>
<p><a href="http://www.boost.org/doc/libs/1_55_0/doc/html/boost_asio.html">http://www.boost.org/doc/libs/1_55_0/doc/html/boost_asio.html</a> </p>
<p><code>Boost.Asio</code>にスレッドプールそのものは提供されてないが以下のようにして簡単に実装することができる</p>
<div class="pygments_borland"><pre><span class="cp">#include &lt;thread&gt;</span>
<span class="cp">#include &lt;functional&gt;</span>
<span class="cp">#include &lt;boost/asio.hpp&gt;</span>

<span class="kt">int</span> <span class="n">main</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[]</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">asio</span><span class="o">::</span><span class="n">io_service</span> <span class="n">io_service</span><span class="p">;</span>
    <span class="n">asio</span><span class="o">::</span><span class="n">io_service</span><span class="o">::</span><span class="n">work</span> <span class="n">work</span><span class="p">(</span><span class="n">io_service</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threadPool</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span><span class="n">size_t</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">hardware_concurrency</span><span class="p">();</span> <span class="n">t</span><span class="o">++</span><span class="p">){</span>
        <span class="n">threadPool</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="kr">thread</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">asio</span><span class="o">::</span><span class="n">io_service</span><span class="o">::</span><span class="n">run</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">io_service</span><span class="p">)));</span>
    <span class="p">}</span>

    <span class="n">io_service</span><span class="p">.</span><span class="n">post</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">an_expensive_calculation</span><span class="p">,</span> <span class="mi">42</span><span class="p">));</span>
    <span class="n">io_service</span><span class="p">.</span><span class="n">post</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">a_long_running_task</span><span class="p">,</span> <span class="mi">123</span><span class="p">));</span>

    <span class="c1">//Do some things with the main thread</span>

    <span class="n">io_service</span><span class="p">.</span><span class="n">stop</span><span class="p">();</span>
    <span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&amp;</span> <span class="n">t</span> <span class="o">:</span> <span class="n">threadPool</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p><a href="http://stackoverflow.com/questions/14265676/using-boostasio-thread-pool-for-general-purpose-tasks">http://stackoverflow.com/questions/14265676/using-boostasio-thread-pool-for-general-purpose-tasks</a> </p>
<p>長くなるのでコードは省略するが、<code>io_service::post</code>するとunixの場合は最終的には<code>task_io_service::wake_one_idle_thread_and_unlock</code>から<code>pthread_cond_signal</code>が呼ばれる。</p>
<h3 id="memcached">memcachedの場合</h3>
<p><a href="https://github.com/memcached/memcached">https://github.com/memcached/memcached</a> </p>
<p><code>libevent</code>のイベント通知機能を利用して実装している。それぞれのthread初期化の際にpipeをつくって、そのfdをlibeventに渡す。 <sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>  libevent内部でそのfdを<code>epoll</code>なり<code>kqueue</code>なりでブロックして待つ。</p>
<div class="pygments_borland"><pre><span class="c1">//</span>
<span class="c1">// memcached.c</span>
<span class="c1">//</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">pthread_t</span> <span class="n">thread_id</span><span class="p">;</span>        <span class="cm">/* unique ID of this thread */</span>
    <span class="k">struct</span> <span class="n">event_base</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>    <span class="cm">/* libevent handle this thread uses */</span>
    <span class="k">struct</span> <span class="n">event</span> <span class="n">notify_event</span><span class="p">;</span>  <span class="cm">/* listen event for notify pipe */</span>
    <span class="kt">int</span> <span class="n">notify_receive_fd</span><span class="p">;</span>      <span class="cm">/* receiving end of notify pipe */</span>
    <span class="kt">int</span> <span class="n">notify_send_fd</span><span class="p">;</span>         <span class="cm">/* sending end of notify pipe */</span>
    <span class="k">struct</span> <span class="n">thread_stats</span> <span class="n">stats</span><span class="p">;</span>  <span class="cm">/* Stats generated by this thread */</span>
    <span class="k">struct</span> <span class="n">conn_queue</span> <span class="o">*</span><span class="n">new_conn_queue</span><span class="p">;</span> <span class="cm">/* queue of new connections to handle */</span>
    <span class="n">cache_t</span> <span class="o">*</span><span class="n">suffix_cache</span><span class="p">;</span>      <span class="cm">/* suffix cache */</span>
    <span class="kt">uint8_t</span> <span class="n">item_lock_type</span><span class="p">;</span>     <span class="cm">/* use fine-grained or global item lock */</span>
<span class="p">}</span> <span class="n">LIBEVENT_THREAD</span><span class="p">;</span>

<span class="c1">//</span>
<span class="c1">// thread.c</span>
<span class="c1">//</span>
<span class="kt">void</span> <span class="nf">thread_init</span><span class="p">(</span><span class="kt">int</span> <span class="n">nthreads</span><span class="p">,</span> <span class="k">struct</span> <span class="n">event_base</span> <span class="o">*</span><span class="n">main_base</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">//</span>
<span class="c1">// 中略</span>
<span class="c1">//</span>
    <span class="n">threads</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">nthreads</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">LIBEVENT_THREAD</span><span class="p">));</span>
<span class="c1">//</span>
<span class="c1">// さらに中略</span>
<span class="c1">//</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nthreads</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">fds</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pipe</span><span class="p">(</span><span class="n">fds</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">perror</span><span class="p">(</span><span class="s">&quot;Can&#39;t create notify pipe&quot;</span><span class="p">);</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">notify_receive_fd</span> <span class="o">=</span> <span class="n">fds</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">notify_send_fd</span> <span class="o">=</span> <span class="n">fds</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

        <span class="n">setup_thread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="cm">/* Reserve three fds for the libevent base, and two for the pipe */</span>
        <span class="n">stats</span><span class="p">.</span><span class="n">reserved_fds</span> <span class="o">+=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Create threads after we&#39;ve done all the libevent setup. */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nthreads</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">create_worker</span><span class="p">(</span><span class="n">worker_libevent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="cm">/* Wait for all the threads to set themselves up before returning. */</span>
    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_lock</span><span class="p">);</span>
    <span class="n">wait_for_thread_registration</span><span class="p">(</span><span class="n">nthreads</span><span class="p">);</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_lock</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<h3 id="pthread_cond_wait">pthread_cond_waitの実装</h3>
<p>脱線するが、pthread_cond_waitがどのようにsleepにはいってるのか気になったので調べた。</p>
<p><a href="https://sourceware.org/git/?p=glibc.git;a=tree;f=nptl;hb=HEAD">https://sourceware.org/git/?p=glibc.git;a=tree;f=nptl;hb=HEAD</a> </p>
<p><code>pthread_cond_wait</code>のソースコードは<code>glibc</code>の<code>nptl</code>以下にある。
<code>__pthread_cond_wait</code>が<code>lll_futex_wait</code>を呼んでおり、これは以下のように実装されている。(以下はx86_64のもの) </p>
<div class="pygments_borland"><pre><span class="cp">#define lll_futex_wait(futex, val, private) \</span>
<span class="cp">  lll_futex_timed_wait(futex, val, NULL, private)</span>

<span class="cp">#define lll_futex_timed_wait(futex, val, timeout, private) \</span>
<span class="cp">  ({                                         \</span>
<span class="cp">    register const struct timespec *__to __asm (&quot;r10&quot;) = timeout;          \</span>
<span class="cp">    int __status;                                \</span>
<span class="cp">    register __typeof (val) _val __asm (&quot;edx&quot;) = (val);                \</span>
<span class="cp">    __asm __volatile (&quot;syscall&quot;                            \</span>
<span class="cp">             : &quot;=a&quot; (__status)                         \</span>
<span class="cp">             : &quot;0&quot; (SYS_futex), &quot;D&quot; (futex),                 \</span>
<span class="cp">           &quot;S&quot; (__lll_private_flag (FUTEX_WAIT, private)),         \</span>
<span class="cp">           &quot;d&quot; (_val), &quot;r&quot; (__to)                    \</span>
<span class="cp">             : &quot;memory&quot;, &quot;cc&quot;, &quot;r11&quot;, &quot;cx&quot;);                 \</span>
<span class="cp">    __status;                                    \</span>
<span class="cp">  })</span>
</pre></div>

<p>上記アセンブラは大体以下のような意味<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> </p>
<div class="pygments_borland"><pre><span class="n">futex</span><span class="p">(</span><span class="n">futex</span><span class="p">,</span> <span class="n">FUTEX_WAIT</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  <span class="c1">// 便宜上、上記コードの引数の変数名をそのままつかっているが、</span>
                                                  <span class="c1">// 1つめのfutexはシステムコールのfutexで、</span>
                                                  <span class="c1">// 2つめは引数のpthread_cond_tの__futexメンバ変数のアドレス</span>
</pre></div>

<blockquote>
<p>futex() システムコールは、 指定したアドレスの値が変更されるのをプログラムが待つ手段や 特定のアドレスに対して待機中のプロセスを wake (起床) させる手段を提供する </p>
<p><a href="http://linuxjm.sourceforge.jp/html/LDP_man-pages/man2/futex.2.html">futex(2) http://linuxjm.sourceforge.jp/html/LDP_man-pages/man2/futex.2.html</a></p>
</blockquote>
<p>とのこと。</p>
<h3 id="_1">まとめ</h3>
<ul>
<li>pthread_cond_waitをつかったもののほうが普通は高速なはず</li>
<li>memcachedのようなやりかただとユーザプロセス側でスレッドプール管理のための排他制御がほとんど不要になるので多少実装が簡単か</li>
</ul>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p><code>pthread_cond_wait</code>はunixの場合。windowsの場合は<code>pSleepConditionVariableCS</code>、これが使えない場合は疑似的に同様の動作をするようなラッパを定義している。&#160;<a href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>memcachedでは使用してないが、libeventはシグナルを通知する際もfdをつかう。Boost.Asioもシグナル通知はpipeを経由する。&#160;<a href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:3">
<p>厳密には違う。&#160;<a href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
</ol>
</div>]]></content:encoded>
    </item>
    <item>
      <title>オーバーフローしにくい組み合わせの数の計算方法</title>
      <link>http://mojavy.com/blog/2013/10/17/calculate-combinations/</link>
      <pubDate>Thu, 17 Oct 2013 21:13:58 JST</pubDate>
      <category><![CDATA[algorithms]]></category>
      <category><![CDATA[programming]]></category>
      <guid isPermaLink="true">http://mojavy.com/blog/2013/10/17/calculate-combinations/</guid>
      <description>オーバーフローしにくい組み合わせの数の計算方法</description>
      <content:encoded><![CDATA[<p>Cで組み合わせの数を計算するときに定義通り計算するとすぐにオーバーフローしてしまう。
例えば以下のような実装だと、<img src="/images/cca79b0e713c769c64899333d0fe43e6.png"> 程度でも結果がおかしくなってしまう。</p>
<div class="pygments_borland"><pre><span class="cp">#include &lt;iostream&gt;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="n">uint64_t</span> <span class="n">fac</span><span class="p">(</span><span class="n">uint64_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">fac</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">uint64_t</span> <span class="n">combinations</span><span class="p">(</span><span class="n">uint64_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">uint64_t</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">fac</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">fac</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">fac</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">k</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">combinations</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// =&gt; 10</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">combinations</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// =&gt; 252</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">combinations</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// =&gt; 184756</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">combinations</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// =&gt; 0 !?</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>とりあえず素因数分解してやれば解決するのでいままでそうしてたのだけど、もっとかっこいい方法がないものかと思って探してみたらKnuth先生の本で以下のようなアルゴリズムが紹介されているらしい。<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 
これはかっこいい。</p>
<div class="pygments_borland"><pre><span class="n">uint64_t</span> <span class="n">combinations2</span><span class="p">(</span><span class="n">uint64_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">uint64_t</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uint64_t</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">uint64_t</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">;</span> <span class="o">++</span><span class="n">d</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">r</span> <span class="o">*=</span> <span class="n">n</span><span class="o">--</span><span class="p">;</span>
        <span class="n">r</span> <span class="o">/=</span> <span class="n">d</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">combinations2</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// =&gt; 155117520</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">combinations2</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// =&gt; 118264581564861424</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">combinations2</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// これはオーバーフローする</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>結果の値が範囲内ならオーバーフローしないのか、というとそういうわけではないけどナイーブな実装に比べるとずっと計算できる範囲が広いので、値のレンジがあらかじめわかっているのであればこれで十分ですね。</p>
<iframe src="http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=armyofpigs-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=4756145434" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>

<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p><a href="http://stackoverflow.com/questions/1838368/calculating-the-amount-of-combinations">http://stackoverflow.com/questions/1838368/calculating-the-amount-of-combinations</a>   残念ながらvol2は手元にはない&#160;<a href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>]]></content:encoded>
    </item>
    <item>
      <title>C言語でtuple</title>
      <link>http://mojavy.com/blog/2013/07/10/c-tuple/</link>
      <pubDate>Wed, 10 Jul 2013 21:02:39 JST</pubDate>
      <category><![CDATA[C]]></category>
      <category><![CDATA[programming]]></category>
      <guid isPermaLink="true">http://mojavy.com/blog/2013/07/10/c-tuple/</guid>
      <description>C言語でtuple</description>
      <content:encoded><![CDATA[<p>Cをつかってるとtupleっぽいものがあれば便利なのに、と思うときが時々あります。</p>
<p>別にtupleなんてなくても</p>
<div class="pygments_borland"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
   <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
   <span class="kt">int</span> <span class="o">*</span><span class="n">i</span><span class="p">;</span>
<span class="p">}</span> <span class="n">tuple</span><span class="p">;</span>
</pre></div>

<p>のようにして構造体をつかえばいいのですが、必要になるたびにこれをするのはちょっとめんどくさいですよね。</p>
<p>というわけで色々試行錯誤してみたところ、以下のようにしてunionの配列にするというのがそこそこ便利だったので紹介します。</p>
<p>以下は使用例です。</p>
<div class="pygments_borland"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span> <span class="n">tuple_u</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">tuple_u</span> <span class="n">tuple</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">tuple</span> <span class="n">t</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span> <span class="p">.</span><span class="n">s</span> <span class="o">=</span> <span class="s">&quot;hoge&quot;</span> <span class="p">},</span> <span class="p">{</span> <span class="p">.</span><span class="n">i</span> <span class="o">=</span> <span class="mi">123</span> <span class="p">}</span> <span class="p">};</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s, %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">i</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>C99のdesignated initializerをつかえば初期化もまあそこそこ書きやすいし、型の組み合わせもある程度柔軟にできます。</p>
<p>C++ではなくあえてCをつかうような人の多くは独自のコンテナライブラリのようなものをもってると思いますが、上記のようなtupleがあれば便利な場面は結構あるのではないかと思います。</p>]]></content:encoded>
    </item>
    <item>
      <title>The P Convention</title>
      <link>http://mojavy.com/blog/2013/02/24/the-p-convention/</link>
      <pubDate>Sun, 24 Feb 2013 14:42:00 JST</pubDate>
      <category><![CDATA[lisp]]></category>
      <category><![CDATA[programming]]></category>
      <guid isPermaLink="true">http://mojavy.com/blog/2013/02/24/the-p-convention/</guid>
      <description>The P Convention</description>
      <content:encoded><![CDATA[<p><img alt="lisp" src="/images/lisplogo_fancy_128.png" /></p>
<p>Lispには'p'という接尾辞がつく名前の関数があるが、この'p'はpredicateのこと。</p>
<p><a href="http://catb.org/jargon/html/p-convention.html">The -P Convention</a></p>
<p>ところが、HaskellやOCamlにも'p'という接尾辞がつく関数があって、そちらはprimeの意味で使うらしい。
シングルクオート(ダッシュ)記号は英語だとprimeというので、例えば<code>foo'</code>という名前の関数は<code>foo</code>という名前のヘルパー関数的なもの、ということになる。</p>
<p><a href="http://stackoverflow.com/questions/5279286/foop-a-naming-convention-its-a-helper-recursive-function-for-foo-what-do">“foop”: a naming convention? It's a helper recursive function for “foo”; what does the suffix “p” mean?</a></p>
<p>ちなみに、OCamlだとシングルクオートが識別子につかえるのでfoo'という名前の関数も結構あるらしい。</p>
<p>まぎらわしい、かと思ったけど使う文脈が違うし意外とそうでもないか。</p>]]></content:encoded>
    </item>
    <item>
      <title>人気プログラミング言語ランキング(stackoverflow調べ)</title>
      <link>http://mojavy.com/blog/2013/02/05/popular-programming-languages/</link>
      <pubDate>Tue, 05 Feb 2013 23:00:00 JST</pubDate>
      <category><![CDATA[programming]]></category>
      <guid isPermaLink="true">http://mojavy.com/blog/2013/02/05/popular-programming-languages/</guid>
      <description>人気プログラミング言語ランキング(stackoverflow調べ)</description>
      <content:encoded><![CDATA[<p><img alt="stack" src="/images/stackoverflow-200.png" /></p>
<p>なんとなく気になったのでstackoverflowのでの人気プログラミング言語ランキングをつくってみました。(2013-02-05現在)</p>
<div class="pygments_borland"><pre>1.   c#              411382pt
2.   java            361120pt
3.   php             337941pt
4.   javascript      321791pt
5.   c++             175790pt
6.   python          160796pt
7.   html            145373pt
8.   objective-c     119891pt
9.   sql             115147pt
10.  css             113039pt
11.  c               83501pt
12.  ruby            64350pt
13.  xml             56444pt
14.  regex           51670pt
15.  vb.net          41260pt
16.  html5           27217pt
17.  linq            26200pt
18.  actionscript-3  24286pt
19.  perl            24092pt
20.  r               23256pt
21.  delphi          18866pt
22.  tsql            18119pt
23.  matlab          15289pt
24.  xaml            14115pt
25.  scala           13444pt
26.  vba             12300pt
27.  css3            11564pt
28.  xslt            11032pt
29.  haskell         9827pt
30.  assembly        7580pt
31.  razor           7385pt
32.  actionscript    6440pt
33.  excel-vba       6309pt
34.  groovy          5551pt
35.  vbscript        4926pt
36.  c++11           4894pt
37.  vb6             4886pt
38.  xhtml           4675pt
39.  plsql           4548pt
40.  svg             4540pt
41.  f#              4341pt
42.  python-3.x      4229pt
43.  awk             3481pt
44.  wsdl            3249pt
45.  lua             3183pt
46.  erlang          3077pt
47.  coffeescript    2754pt
48.  c#-3.0          2615pt
49.  latex           2570pt
50.  lisp            2395pt
51.  mathematica     2395pt
52.  prolog          2317pt
53.  scheme          2199pt
54.  uml             2093pt
55.  applescript     2092pt

-- 次点

go         1648pt
ocaml      1329pt
d          877pt
</pre></div>

<h3 id="_1">補足</h3>
<ul>
<li>stackoverflow APIを利用して調べました。stackoverflow公式のものではありません。</li>
<li>ランキングは質問につけられたタグの件数順です。</li>
<li>プログラミング言語のタグは、tag infoのエントリに/language/i がマッチするかどうかで抽出し、明らかにプログラミング言語じゃないものは手動で適当に除外しました。</li>
<li>マークアップ言語とかバージョン違いで複数ある言語とか微妙なのはそのまま残しました。</li>
<li>次点以下の言語は、apiをしばらくクロールしてもでてこなかった言語のうち思いついたものを手動でしらべました。</li>
</ul>
<h3 id="_2">所感</h3>
<p>C#が1位なのはちょっと意外でしたがそれ以外は大体イメージ通りでした。
質問が多い順でもあるので、下位にある言語は質問が少なくて逆にイケてると言えなくもないですね。</p>
<p>D言語すばらしい。</p>
<p>ともあれ、stackoverflowのAPIは結構充実してるので色々遊べそうです。</p>
<ul>
<li><a href="http://api.stackoverflow.com/1.0/usage">http://api.stackoverflow.com/1.0/usage</a></li>
</ul>]]></content:encoded>
    </item>
    <item>
      <title>C言語の文字列初期化について</title>
      <link>http://mojavy.com/blog/2013/01/21/c-string-initialization/</link>
      <pubDate>Mon, 21 Jan 2013 20:00:00 JST</pubDate>
      <category><![CDATA[C]]></category>
      <category><![CDATA[programming]]></category>
      <guid isPermaLink="true">http://mojavy.com/blog/2013/01/21/c-string-initialization/</guid>
      <description>C言語の文字列初期化について</description>
      <content:encoded><![CDATA[<p>なんとなく気になったので以下ひとりごと。</p>
<hr>

<p>Cで文字列を初期化するときは以下のように書く。</p>
<div class="pygments_borland"><pre>char str[] = &quot;xyz&quot;;
</pre></div>

<p>こう書けばNULL終わりのchar配列としてスタックに格納してくれるので、以下のように書くのと同じことになる。</p>
<div class="pygments_borland"><pre>char str1[4] = &quot;xyz&quot;;
char str2[4] = {&#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;\0&#39;};
</pre></div>

<p>文字列はcharのポインタで扱うからといって、</p>
<div class="pygments_borland"><pre>char *str = &quot;xyz&quot;;
</pre></div>

<p>のように書くと違う意味になる。
こう書くと"xyz"が格納されているアドレスでポインタを初期化する。文字列リテラルで宣言したデータが格納される領域は通常はread onlyなので<code>*str='X'</code>などとするとセグフォするが、通常の代入と同じ意味なので違和感はない。</p>
<p>でも、<code>char str[] = "xyz";</code> のほうはは冷静に考えると気持ち悪い。初期化と代入は違うといってしまえばそれまでだけど、この式だけみても予備知識がないとなにがおこるのかわからないと思う。</p>
<p>以下のような挙動も合理的とは思えない。そもそもCに配列なんて必要なかったのではないか。</p>
<div class="pygments_borland"><pre>void f1(char s[]) {
    /* 意味はないけどエラーでもない */
    s = &quot;baz&quot;;
}

void f2(void) {
    char s[] = &quot;foo&quot;;
    /* これはエラー */
    /* s = &quot;bar&quot;; */
}
</pre></div>

<p>などということを今更ながら考えて悶々としていたのだけど、結局のところこういう類の便利機能は欲しくなってくるわけで、便利さのために不合理を許容するとなるとこのあたりが妥当な落とし所のような気もしてきた。</p>
<p>まとめ：プログラミング言語を考える人はすごい</p>]]></content:encoded>
    </item>
  </channel>
</rss>
