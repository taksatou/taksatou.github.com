<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <title>mojavy.com</title>
    <link>http://mojavy.com/blog</link>
    <description></description>
    <pubDate>Fri, 22 Feb 2013 23:55:00 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    <item>
      <title>pythonのsubprocess.Popen()でpipeしてwaitするとデッドロックしてはまった件</title>
      <link>http://mojavy.com/blog/2013/02/22/python-popen/</link>
      <pubDate>Fri, 22 Feb 2013 23:55:00 JST</pubDate>
      <category><![CDATA[python]]></category>
      <category><![CDATA[unix]]></category>
      <guid isPermaLink="true">http://mojavy.com/blog/2013/02/22/python-popen/</guid>
      <description>pythonのsubprocess.Popen()でpipeしてwaitするとデッドロックしてはまった件</description>
      <content:encoded><![CDATA[<p><img alt="python" src="/images/python-logo.gif" /></p>
<p>pythonのsubprocess.Popen()を使っていてはまってしまったのでメモ。</p>
<p>処理を並列化するために、Popenで起動した複数の子プロセスに対してpipeで入力データを渡して処理させてやろうと以下のようなコードを書いた。
(ここでは便宜上catコマンドを起動しているが、実際はワーカープロセスのコマンド)</p>
<div class="pygments_murphy"><pre><span class="kn">import</span> <span class="nn">subprocess</span>

<span class="n">children</span> <span class="o">=</span> <span class="p">[</span><span class="n">subprocess</span><span class="o">.</span><span class="n">Popen</span><span class="p">(</span><span class="s">&quot;cat&quot;</span><span class="p">,</span> <span class="n">stdin</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="c">#</span>
<span class="c"># do something</span>
<span class="c">#</span>
<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
    <span class="n">child</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">child</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
</pre></div>

<p>子プロセスは標準入力がEOFを返したら終了するようにしてあったので、上のコードでも問題なさそうに見えるがwaitでデッドロックする。
python2.7.3以降だと問題なかったのだけど、python2.5や2.6だと必ずデッドロックしてしまう。</p>
<p>さんざん悩んだあげくsubprocess.pyのソースを読んでみたら、close_fds=TrueをPopenの引数に渡してやればよいことに気づいた。</p>
<p>要するに、子プロセスが自分の標準入力のパイプをオープンしたままexecしてしまっていたのが原因だった。
forkするとファイルディスクリプタも引き継ぐので、pipeで開いた書込み側のファイルディスクリプタを親と子の両方できちんと閉じてやらないと、標準入力の書込み側がオープンしたままの状態になってしまいEOFがこなくなってしまう。</p>
<p>Popenではclose_fdsにTrueを渡してやるとexecするまえに3以上のファイルディスクリプタをすべて閉じるようになっている。
(O_CLOEXECフラグを使うのではなく単にループして全部なめるような実装になっていた)</p>
<p>というわけで、pipe使うときに標準入出力以外のファイルディスクリプタを引き継ぐ必要性はあまりないと思うので、close_fdsを設定するのを忘れないように気をつけましょう
(Linux以外のプラットフォームでどうなるかは未調査です)</p>]]></content:encoded>
    </item>
    <item>
      <title>ワンライナーでウェブサーバを起動する方法</title>
      <link>http://mojavy.com/blog/2012/07/18/one-line-webserver/</link>
      <pubDate>Wed, 18 Jul 2012 12:30:00 JST</pubDate>
      <category><![CDATA[python]]></category>
      <category><![CDATA[web]]></category>
      <category><![CDATA[ruby]]></category>
      <guid isPermaLink="true">http://mojavy.com/blog/2012/07/18/one-line-webserver/</guid>
      <description>ワンライナーでウェブサーバを起動する方法</description>
      <content:encoded><![CDATA[<p><img alt="ruby" src="/images/ruby-logo.png" /></p>
<p>とりあえずウェブサーバがたちあがりさえすればいいときは、pythonのSimpleHTTPServerを使うのが便利です。
起動したカレントディレクトリ以下のファイルをブラウズできるので、テスト用のスタティックなスタブデータを一時的に配置したいときとかにも使えます。最近の一般的なlinuxディストリビューションであればデフォルトではいってるpythonで使えると思います。</p>
<div class="pygments_murphy"><pre><span class="nv">$ </span>python -mSimpleHTTPServer 3333
</pre></div>

<p>デフォルトポートは8000ですが、引数で指定することもできます。
<br>
ちなみにrubyでもwebrickを使って同様のことができますが、<a href="http://d.hatena.ne.jp/rx7/20090812/p1">こちら</a> で紹介されているwebrickのワンライナーは長すぎて覚えられないのでいつもpythonを使ってます。
<br>
<br>
でもリクエストに応じたロジックを入れたい場合はrubyのsinatraの方が便利です。</p>
<div class="pygments_murphy"><pre><span class="nv">$ </span>ruby -rsinatra -e <span class="s1">&#39;get(&quot;/&quot;){sleep 3}&#39;</span>
</pre></div>

<p>ポートを変更する場合は以下のようにします</p>
<div class="pygments_murphy"><pre><span class="nv">$ </span>ruby -rsinatra -e <span class="s1">&#39;set :port,3333; get(&quot;/&quot;){sleep 3}&#39;</span>
</pre></div>

<h2 id="_1">参考</h2>
<ul>
<li><a href="http://d.hatena.ne.jp/rx7/20090812/p1">コマンド1つで今すぐWebサーバを起動させるためのワンライナー(Ruby or Python)</a></li>
</ul>]]></content:encoded>
    </item>
    <item>
      <title>debian lennyのEnd Of Life対応</title>
      <link>http://mojavy.com/blog/2012/06/06/debian-lenny-oldstable/</link>
      <pubDate>Wed, 06 Jun 2012 10:30:00 JST</pubDate>
      <category><![CDATA[python]]></category>
      <guid isPermaLink="true">http://mojavy.com/blog/2012/06/06/debian-lenny-oldstable/</guid>
      <description>debian lennyのEnd Of Life対応</description>
      <content:encoded><![CDATA[<p><img alt="debian" src="/images/debian_logo.png" /></p>
<p>debian lennyは2012-02-06にEnd of lifeを迎えました。
それに伴いlennyのリポジトリもoldstable扱いとなりパスが変わったため、デフォルトのsources.listでは404 Not Foundとなってパッケージがインストールできなくなってしまいました。
早めにアップデートしたほうが好ましいですが、そのまま引き続きlennyを使いたい場合もあると思います。
そのような場合は以下のようにsources.listを変更してやれば今までどおりパッケージをとれるようになります。</p>
<div class="pygments_murphy"><pre>deb http://archive.debian.org/debian-security/ lenny/updates main
deb-src http://archive.debian.org/debian-security/ lenny/updates main

deb http://archive.debian.org/debian/ lenny main
deb-src http://archive.debian.org/debian/ lenny main
</pre></div>

<p>backportsなどもarchiveのほうにあるのでお好みで追加してください。</p>
<h1 id="_1">参考</h1>
<ul>
<li><a href="http://archive.debian.org/">http://archive.debian.org/</a></li>
<li><a href="http://wiki.debian.org/DebianLenny">http://wiki.debian.org/DebianLenny</a></li>
<li><a href="http://wiki.debian.org/DebianOldStable">http://wiki.debian.org/DebianOldStable</a></li>
</ul>
<p><br></p>]]></content:encoded>
    </item>
    <item>
      <title>1分でpython環境を整える方法</title>
      <link>http://mojavy.com/blog/2012/04/22/virtualenv-burrito/</link>
      <pubDate>Sun, 22 Apr 2012 17:30:00 JST</pubDate>
      <category><![CDATA[python]]></category>
      <guid isPermaLink="true">http://mojavy.com/blog/2012/04/22/virtualenv-burrito/</guid>
      <description>1分でpython環境を整える方法</description>
      <content:encoded><![CDATA[<p><img alt="python" src="/images/python-logo.gif" /></p>
<p>pythonではvirtualenvというユーティリティを使って複数の環境を切り替えることができます。しかしvirtualenvはセットアップがちょっとわかりにくかったりバージョンによってはこけたりしていまいち使いこなせていませんでした。久し振りにブログを書くついでにpython環境を再構築しようと思って調べたところ、<a href="https://github.com/brainsik/virtualenv-burrito">virtualenv-burrito</a> というのが使いやすかったので紹介します。これを使えば非常に簡単にpython環境を整えることができます。</p>
<h1 id="_1">インストール</h1>
<div class="pygments_murphy"><pre><span class="nv">$ </span>curl -s https://raw.github.com/brainsik/virtualenv-burrito/master/virtualenv-burrito.sh | <span class="nv">$SHELL</span>
</pre></div>

<p>として再ログインするだけです。勝手にパスやシェルの補完設定もしてくれます。</p>
<h1 id="_2">使い方</h1>
<p>新しい環境の構築は、</p>
<div class="pygments_murphy"><pre><span class="nv">$ </span>mkvirtualenv newname
</pre></div>

<p><br></p>
<p>環境の切り替えは、</p>
<div class="pygments_murphy"><pre><span class="nv">$ </span>workon newname
<span class="nv">$ </span><span class="c"># or</span>
<span class="nv">$ </span>workon 2.7
</pre></div>

<p><br></p>
<p>不要な環境の削除は、</p>
<div class="pygments_murphy"><pre><span class="nv">$ </span>rmvirtualenv newname
</pre></div>

<p><br></p>
<p>以上が基本的な使い方です。さらに詳しい使い方は<a href="http://www.doughellmann.com/docs/virtualenvwrapper/command_ref.html">virtualenvwrapperのコマンドリファレンス</a>等をみてください。</p>
<h1 id="_3">解説</h1>
<p>virtualenv-burrito自体はvirtualenv+virtualenvwrapperの環境を構築するだけなので、本格的に使いたい場合はvirtualenvについての理解が必要です。ただ、ほとんどの場合は単にバージョンとパッケージが切り替えられればいいと思うので、mkvirtualenvとworkonさえ覚えておけば十分です。
いくつか注意点もあります。</p>
<ul>
<li>pythonのバイナリはあらかじめインストールされている必要があります。</li>
<li>python3だとうごきません。python3環境が作れないという意味ではなく、デフォルトパスのpythonバージョンが3だとvirtualenv-burritoのセットアップ途中でこけます。その場合はpython2系をつかってください。</li>
<li>pipのインストールでこける場合があります。その場合は以下のようなコマンドで回避できます。 <a href="https://github.com/brainsik/virtualenv-burrito/issues/16">(参考)</a></li>
</ul>
<div class="pygments_murphy"><pre><span class="nv">$ </span>rm -Rf ~/.venvburrito/lib/python/distribute-0.6.24-py2.7.egg
<span class="nv">$ </span>mkvirtualenv -p <span class="k">$(</span>which python3.2<span class="k">)</span> --distribute py32
</pre></div>

<h1 id="_4">まとめ</h1>
<p>いまからpython環境を構築するならvirtualenv-burritoつかっとくと、virtualenvとvirtualenvwrapperをセットアップするまでの手間が省けていいと思います</p>
<h1 id="_5">関連リンク</h1>
<ul>
<li><a href="https://github.com/brainsik/virtualenv-burrito">virtualenv-burrito</a></li>
<li><a href="http://pypi.python.org/pypi/virtualenv">virtualenv</a></li>
<li><a href="http://www.doughellmann.com/docs/virtualenvwrapper/">virtualenvwrapper</a>
<br></li>
</ul>]]></content:encoded>
    </item>
    <item>
      <title>blogofileでサムネイル画像を表示する方法</title>
      <link>http://mojavy.com/blog/2011/11/06/blofofile-test/</link>
      <pubDate>Sun, 06 Nov 2011 20:32:51 JST</pubDate>
      <category><![CDATA[python]]></category>
      <category><![CDATA[memo]]></category>
      <category><![CDATA[blogofile]]></category>
      <guid isPermaLink="true">http://mojavy.com/blog/2011/11/06/blofofile-test/</guid>
      <description>blogofileでサムネイル画像を表示する方法</description>
      <content:encoded><![CDATA[<p><img alt="rena" src="/images/rena.jpg" /></p>
<p>こんな風にイメージ画像がある記事の場合は、一覧ページでもこの画像をサムネイルで表示させたい。</p>
<p>例えば、
<a href="http://mojavy.com">http://mojavy.com</a>
のトップページ右カラムにある最近の記事一覧みたいに画像を表示できるようにする。</p>
<p>これをするには、postオブジェクトにそういう属性をもたせればよいので、controllers/blog/post.pyに以下のように一行追加する。</p>
<div class="pygments_murphy"><pre><span class="gi">+++ b/_blogofile/_controllers/blog/post.py</span>
<span class="gu">@@ -93,6 +93,7 @@ class Post(object):</span>
         self.slug = None
         self.draft = False
         self.filters = None
<span class="gi">+        self.image = None</span>
         self.__parse()
         self.__post_process()
</pre></div>

<p>そうしておくと、各記事のヘッダにあるyamlから勝手に読み込んでくれるので、</p>
<div class="pygments_murphy"><pre><span class="l-Scalar-Plain">categories</span><span class="p-Indicator">:</span>
<span class="l-Scalar-Plain">date</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">2011/11/06 20:32:51</span>
<span class="l-Scalar-Plain">title</span><span class="p-Indicator">:</span>
<span class="l-Scalar-Plain">image</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">/images/rena.jpg</span>
</pre></div>

<p>のようにすれば${post.image}のようにして参照できる。</p>
<ul>
<li><a href="https://github.com/taksatou/taksatou.github.com">https://github.com/taksatou/taksatou.github.com</a></li>
</ul>]]></content:encoded>
    </item>
  </channel>
</rss>
