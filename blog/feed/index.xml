<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <title>mojavy.com</title>
    <link>http://mojavy.com/blog</link>
    <description></description>
    <pubDate>Thu, 13 Feb 2014 09:10:00 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    <item>
      <title>あなたのgithub pagesを無料で高速化する方法</title>
      <link>http://mojavy.com/blog/2014/02/13/faster-github-pages/</link>
      <pubDate>Thu, 13 Feb 2014 09:10:00 JST</pubDate>
      <category><![CDATA[web]]></category>
      <category><![CDATA[github]]></category>
      <guid isPermaLink="true">http://mojavy.com/blog/2014/02/13/faster-github-pages/</guid>
      <description>あなたのgithub pagesを無料で高速化する方法</description>
      <content:encoded><![CDATA[<p><img alt="github" src="/images/github-logo-transparent-200.png" /> </p>
<p>このブログはgithub pages上に構築していますが、github pagesに引きずられて自分のブログも重くなるということが時々ありました。</p>
<p>がんばってブログを書いた次の日にアクセスできなくなってたりすると悲しいので何とか高速かつ安定した配信をする方法ないかなーと思って調べてみたところ、なんとgithub pagesに置いたコンテンツをCDNから配信させることができるようになったらしいです!</p>
<p><a href="https://github.com/blog/1715-faster-more-awesome-github-pages">Faster, More Awesome GitHub Pages</a> </p>
<p>どういうドメインでgithub pagesを配信しているかによって対応方法は違うので以下を読んで各自適切な設定をして下さい。</p>
<p><strong>目次</strong></p>
<div class="toc">
<ul>
<li><a href="#github-pages-usernamegithubio">デフォルトのgithub pagesのドメイン( username.github.io ) を使用している場合</a></li>
<li><a href="#wwwexamplecom">カスタムサブドメイン ( www.example.com ) を使用している場合</a></li>
<li><a href="#apex-examplecom">Apexドメイン ( example.com ) を使用している場合</a><ul>
<li><a href="#comdnsimple">お名前.comからDNSimpleに移行する場合</a><ul>
<li><a href="#1-dnsimple">1. DNSimpleに登録する</a></li>
<li><a href="#2-dnsimplegithub-pages">2. DNSimpleでgithub pagesとの連携を開始する</a></li>
<li><a href="#3">3. ネームサーバの設定をする</a></li>
<li><a href="#4-dns">4. dnsの更新を確認する</a></li>
<li><a href="#5-cdn">5. CDNの確認</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_1">その他参考</a></li>
<li><a href="#_2">まとめ</a></li>
</ul>
</div>
<h2 id="github-pages-usernamegithubio">デフォルトのgithub pagesのドメイン( username.github.io ) を使用している場合</h2>
<p>既に対応しています。
なにもやる必要はありません。</p>
<h2 id="wwwexamplecom">カスタムサブドメイン ( www.example.com ) を使用している場合</h2>
<p>CNAMEの向き先をusername.github.io に向けるだけで対応できます。</p>
<h2 id="apex-examplecom">Apexドメイン ( example.com ) を使用している場合</h2>
<p>Apexドメインというのはサブドメインでない基本のドメイン部分のことで、そこを直接github pagesにIPに向くようにAレコードに設定している場合です。</p>
<p>この場合はDNSのプロバイダがALIASレコードをサポートしていれば、ALIASが <code>username.github.io</code> を向くようにすることで対応できます。</p>
<p>ALIASレコードに対応していない場合は残念ながらCDNを有効にできません。ちなみにお名前.comはALIASには対応していないので、その場合は他のDNSプロバイダに移行するしかありません。</p>
<h3 id="comdnsimple">お名前.comからDNSimpleに移行する場合</h3>
<p>このブログは残念ながらお名前.comでApexドメインをgithub pagesのIPに向けていたのでDNSimpleに移行することにしました。以下はお名前.comからDNSimpleに移行した際の手順です。</p>
<p>なお、この場合はタイトルに反して無料ではありません。</p>
<p>(ちなみにここではドメインの移管はせずに、DNSの設定だけをDNSimpleに移しました)</p>
<h4 id="1-dnsimple">1. DNSimpleに登録する</h4>
<p>DNSimpleはユーザビリティに主眼を置いたDNSサービスのようで<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 、APIでDNSレコードを更新したりAWSやHerokuやgithub pagesといったクラウドサービスとの連携が簡単にできます。</p>
<p><a href="https://dnsimple.com/r/4388f43fedebae">
<img alt="dnsimple" src="/images/dnsimple.png" /> </p>
<p><strong>DNSimple</strong>
</a></p>
<p>登録時に対象ドメインを聞かれるので、そのとき移行したいドメインを入力します。</p>
<p>ちなみに月額3ドルから<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> ですが30日は無料でつかえます。誰かを紹介すると、紹介した人とされた人の両方の無料期間が伸びます。上のリンクにはキャンペーンコードが埋め込まれているので、この記事を読んだ人はぜひ上のリンクから登録してください。</p>
<p>登録が完了するだけで一通りのUIが使えるようになりますが、DNS機能が有効になるのは決済情報を入力してからです。</p>
<h4 id="2-dnsimplegithub-pages">2. DNSimpleでgithub pagesとの連携を開始する</h4>
<p><a href="https://dnsimple.com/domains">dnsimpleの管理画面</a> に行くとServicesというボタンがあるのでそこからgithub pagesと連携を開始します。</p>
<h4 id="3">3. ネームサーバの設定をする</h4>
<p>お名前.com の以下のページの「他のネームサーバーを利用」からDNSimpleのネームサーバを指定します。</p>
<p><a href="https://www.onamae.com/domain/navi/ns_update/input?btn_id=navi_menu_domain_nsupdate_leftmenu_12">https://www.onamae.com/domain/navi/ns_update/input?btn_id=navi_menu_domain_nsupdate_leftmenu_12</a> </p>
<p>登録するサーバは以下です。</p>
<ul>
<li>ns1.dnsimple.com</li>
<li>ns2.dnsimple.com</li>
<li>ns3.dnsimple.com</li>
<li>ns4.dnsimple.com</li>
</ul>
<p><a href="http://support.dnsimple.com/articles/dnsimple-nameservers">参考 - DNSimple Name Servers</a> </p>
<p>この段階ではお名前.com側で設定しているAレコードはそのまま残しておきます。変更するのはネームサーバのみです。
そうしておかないと、ネームサーバの変更が伝搬するまでの間にお名前.comに問いあわせが来た場合NXDOMAIN扱いになってします。</p>
<h4 id="4-dns">4. dnsの更新を確認する</h4>
<p>更新前は以下</p>
<div class="pygments_borland"><pre>% dig mojavy.com
mojavy.com.             259     IN      A       207.97.227.245
</pre></div>

<p>もしくは以下</p>
<div class="pygments_borland"><pre>% dig mojavy.com
mojavy.com.             259     IN      A       204.232.175.78
</pre></div>

<p>のようになっていたはずですが、反映が完了すれば上記とは違うIPが返ってくるはずです。
反映までには時間がかかるので気長に待ちます。完全に反映されるには3日ほどかかるようです。</p>
<div class="pygments_borland"><pre>% dig mojavy.com
mojavy.com.             3600    IN      A       103.245.222.133

% dig taksatou.github.io
taksatou.github.io.     2973    IN      CNAME   github.map.fastly.net.
github.map.fastly.net.  15      IN      A       103.245.222.133
</pre></div>

<h4 id="5-cdn">5. CDNの確認</h4>
<p><a href="http://www.webpagetest.org/">webpagetest</a> のような計測ツールを使ってもいいですが、CDNからのレスポンスは<code>X-xxx</code>のようなヘッダがつくようなのでcurlでも確認できます。</p>
<div class="pygments_borland"><pre>% curl -v mojavy.com 2&gt;&amp;1  &gt; /dev/null  | grep &#39;X-&#39;
&lt; X-Served-By: cache-ty67-TYO
&lt; X-Cache: HIT
&lt; X-Cache-Hits: 5
&lt; X-Timer: S1392104522.668435574,VS0,VE0
</pre></div>

<p>もう完全に反映されたと思ったらお名前.com側で設定しているAレコードは無効にして大丈夫です。</p>
<h2 id="_1">その他参考</h2>
<ul>
<li><a href="https://help.github.com/articles/setting-up-a-custom-domain-with-pages">https://help.github.com/articles/setting-up-a-custom-domain-with-pages</a> </li>
</ul>
<h2 id="_2">まとめ</h2>
<ul>
<li>github pagesをつかえば無料でCDNから配信できる!</li>
<li>Apexドメインは慎重に使うべきだったという教訓を得た</li>
<li>DNSimple便利</li>
</ul>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>The satisfaction of not having to use GoDaddy!  らしい&#160;<a href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>登録ドメイン数に応じて自動的にプランが切りかわるようです。&#160;<a href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
</ol>
</div>]]></content:encoded>
    </item>
    <item>
      <title>全文検索システムの比較 - Elasticsearch vs Solr vs Amazon CloudSearch</title>
      <link>http://mojavy.com/blog/2014/02/10/search-engine-comparison/</link>
      <pubDate>Mon, 10 Feb 2014 01:05:25 JST</pubDate>
      <category><![CDATA[solr]]></category>
      <category><![CDATA[aws]]></category>
      <category><![CDATA[elasticsearch]]></category>
      <category><![CDATA[web]]></category>
      <guid isPermaLink="true">http://mojavy.com/blog/2014/02/10/search-engine-comparison/</guid>
      <description>全文検索システムの比較 - Elasticsearch vs Solr vs Amazon CloudSearch</description>
      <content:encoded><![CDATA[<p>Elasticsearch、Solr、及び Amazon CloudSearchの比較検討を行った。</p>
<h2 id="_1">目次</h2>
<div class="toc">
<ul>
<li><a href="#_1">目次</a></li>
<li><a href="#_2">候補の選定方法</a></li>
<li><a href="#solr">Solr</a><ul>
<li><a href="#_3">長所</a></li>
<li><a href="#_4">短所</a></li>
</ul>
</li>
<li><a href="#elasticsearch">Elasticsearch</a><ul>
<li><a href="#_5">長所</a></li>
<li><a href="#_6">短所</a></li>
</ul>
</li>
<li><a href="#amazon-cloudsearch">Amazon CloudSearch</a><ul>
<li><a href="#_7">長所</a></li>
<li><a href="#_8">短所</a></li>
</ul>
</li>
<li><a href="#_9">比較項目別のまとめ</a><ul>
<li><a href="#_10">拡張性</a></li>
<li><a href="#_11">性能</a></li>
<li><a href="#_12">安定性</a></li>
<li><a href="#_13">リアルタイムデータ更新</a></li>
<li><a href="#_14">日本語対応</a></li>
<li><a href="#_15">スケーラビリティ</a></li>
</ul>
</li>
<li><a href="#_16">参考リンクまとめ</a></li>
<li><a href="#_17">所感</a></li>
</ul>
</div>
<h2 id="_2">候補の選定方法</h2>
<p>候補を選定するにあたって、以下の特徴をもっていることを前提とした。
LuceneやGroongaを使えば何でもできるが、ここでは対象としない。</p>
<ul>
<li>ウェブベースのインターフェースを持つ</li>
<li>インデックスの更新はほぼリアルタイムに反映される</li>
<li>スケールアウトが容易</li>
</ul>
<h2 id="solr">Solr</h2>
<p><img alt="solr" src="/images/solr-150.png" /> </p>
<p><a href="https://lucene.apache.org/solr/">https://lucene.apache.org/solr/</a> </p>
<p>Luceneをバックエンドにした全文検索システム。バージョン4になってから大幅に機能が増強された。</p>
<h3 id="_3">長所</h3>
<ul>
<li>実績が十分ある</li>
<li>機能豊富</li>
</ul>
<h3 id="_4">短所</h3>
<ul>
<li>クラスタを構築して運用するには手間がかかりそう</li>
<li>SolrCloudはzookeeperに依存するためサーバ台数もかさむ</li>
</ul>
<h2 id="elasticsearch">Elasticsearch</h2>
<p><img alt="Elasticsearch" src="/images/elasticsearch-logo.png" /> </p>
<p><a href="http://www.elasticsearch.org/">http://www.elasticsearch.org/</a> </p>
<p>Solrと同じくLuceneをバックエンドにした全文検索システム。開発者の言<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>によると、Solrより洗練された分散モデルで<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> 、使いやすいAPIを備えている。 </p>
<h3 id="_5">長所</h3>
<ul>
<li>アーキテクチャやUIが今風</li>
<li>クラスタの構築が簡単</li>
<li>KibanaやLogstashと連携できる</li>
<li>Percolate APIというpush通知のような機能を簡単に実装するためのものがある</li>
</ul>
<h3 id="_6">短所</h3>
<ul>
<li>後発な分ノウハウの蓄積にやや不安が残る</li>
<li>未実装機能がいくらかある(あった。現時点(2014-02-09)では機能的にはほぼ追いついているように見える  <a href="http://solr-vs-elasticsearch.com/">http://solr-vs-elasticsearch.com/</a>  )</li>
</ul>
<h2 id="amazon-cloudsearch">Amazon CloudSearch</h2>
<p><img alt="amazon" src="/images/aws-logo-s.png" /> </p>
<p><a href="http://aws.amazon.com/jp/cloudsearch/">http://aws.amazon.com/jp/cloudsearch/</a> </p>
<p>AWS上で提供されている全文検索システム。EC2と同じく時間とトラフィックで課金される。現時点ではまだベータ。</p>
<h3 id="_7">長所</h3>
<ul>
<li>自動的にスケーリングしてくれる(エントリ数、リクエスト数に応じてインスタンスが自動的に増える)</li>
<li>pdfやdocをそのまま送るだけでも適当にうまくやってくれる</li>
<li>DynamoDBのデータをそのまま流してインデックスできる</li>
</ul>
<h3 id="_8">短所</h3>
<ul>
<li>現状では東京リージョンがない</li>
<li>テキスト解析のカスタマイズが限定的。現状、Stemming, Stopwords, Synonymsのみカスタム可能。</li>
<li>N-gramとか形態素解析は自前で処理してからアップロードする必要がある</li>
<li>ヒット位置を取る方法がない</li>
<li>テキスト本文をインデックスと一緒に格納することはできない</li>
</ul>
<h2 id="_9">比較項目別のまとめ</h2>
<h3 id="_10">拡張性</h3>
<p>SolrもElasticsearchもLuceneをバックエンドにしているので、Luceneでできることは基本的にはどちらでもできるはず。
Amazonは現状ではあまり拡張性はない。</p>
<h3 id="_11">性能</h3>
<p>基本性能はSolrもElasticsearchも大差はなさそう。
Amazonは自動的にノードが追加されるので性能の問題はなさそう。ただし、ノードが自動追加されるタイミングとその時の挙動は未確認。</p>
<h3 id="_12">安定性</h3>
<p>数年先行している分Solrがよいと思われるが、Elasticsearchも既に十分本番稼動実績はある。
Amazonはベータなので未知数。</p>
<h3 id="_13">リアルタイムデータ更新</h3>
<p>いずれもほぼリアルタイムに更新できる。</p>
<h3 id="_14">日本語対応</h3>
<p>SolrとElasticsearchはほぼ同等。kuromojiやmecabをつかえば形態素解析もできる。
Amazonはそれ自体では対応していないが、Luceneのtokenizer等を使って自前で前処理することで対応は可能。</p>
<h3 id="_15">スケーラビリティ</h3>
<p>Amazonは完全に自動的にスケールアウトしてくれる。
Elasticsearchはインデックスのシャード数を作成時に決めておく必要があるが、スケールアウトは容易だと思われる。
Solrはv4からはElasticsearchと大体同等のスケーラビリティを備えるようになった。</p>
<h2 id="_16">参考リンクまとめ</h2>
<ul>
<li><a href="http://stackoverflow.com/questions/10213009/solr-vs-elasticsearch">http://stackoverflow.com/questions/10213009/solr-vs-elasticsearch</a> </li>
<li><a href="http://stackoverflow.com/questions/2271600/elasticsearch-sphinx-lucene-solr-xapian-which-fits-for-which-usage">http://stackoverflow.com/questions/2271600/elasticsearch-sphinx-lucene-solr-xapian-which-fits-for-which-usage</a> </li>
<li><a href="http://blog.kakipo.com/trouble-with-fluentd-and-elasticsearch/">http://blog.kakipo.com/trouble-with-fluentd-and-elasticsearch/</a> </li>
<li><a href="https://github.com/atilika/kuromoji">https://github.com/atilika/kuromoji</a> </li>
<li><a href="http://www.elasticsearch.org/blog/percolator/">http://www.elasticsearch.org/blog/percolator/</a> </li>
<li><a href="http://blog.feedbin.me/2013/11/10/powering-actions-with-elasticsearch-percolate/">http://blog.feedbin.me/2013/11/10/powering-actions-with-elasticsearch-percolate/</a> </li>
<li><a href="http://docs.aws.amazon.com/cloudsearch/latest/developerguide/text-processing.html">http://docs.aws.amazon.com/cloudsearch/latest/developerguide/text-processing.html</a> </li>
<li><a href="http://blog.mikemccandless.com/2011/06/lucenes-near-real-time-search-is-fast.html">http://blog.mikemccandless.com/2011/06/lucenes-near-real-time-search-is-fast.html</a> </li>
<li><a href="https://wiki.apache.org/solr/Solr4.0">https://wiki.apache.org/solr/Solr4.0</a> </li>
<li><a href="http://www.slideshare.net/kucrafal/battle-of-the-giants-apache-solr-vs-elasticsearch">http://www.slideshare.net/kucrafal/battle-of-the-giants-apache-solr-vs-elasticsearch</a> </li>
</ul>
<h2 id="_17">所感</h2>
<p>後発な分Elasticsearchが一番洗練されているように思います。
Solrは無難に導入できそうですが、スケールアウトが必要になったとき手間がかかりそうです。
Amazonはメリットも多いですが、現状では制限が多いので使いづらいと思います。</p>
<p><strong>追記</strong></p>
<ul>
<li>2014/02/12 23:59:13： ElasticSearch →  Elasticsearchに直しました</li>
</ul>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p><a href="http://stackoverflow.com/questions/2271600/elasticsearch-sphinx-lucene-solr-xapian-which-fits-for-which-usage">http://stackoverflow.com/questions/2271600/elasticsearch-sphinx-lucene-solr-xapian-which-fits-for-which-usage</a> &#160;<a href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>昔のSolrは単純なレプリケーションとシャーディングしかなかったので、クラスタを構築するのは大変だった&#160;<a href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
</ol>
</div>]]></content:encoded>
    </item>
    <item>
      <title>Goのtemplateパッケージ簡易チートシート</title>
      <link>http://mojavy.com/blog/2013/11/19/go-template/</link>
      <pubDate>Tue, 19 Nov 2013 19:19:57 JST</pubDate>
      <category><![CDATA[golang]]></category>
      <guid isPermaLink="true">http://mojavy.com/blog/2013/11/19/go-template/</guid>
      <description>Goのtemplateパッケージ簡易チートシート</description>
      <content:encoded><![CDATA[<p>goに標準でついてるtemplateパッケージは便利なのだけど、<a href="http://golang.org/pkg/text/template/">マニュアル</a>が長すぎるのでよく使う機能だけまとめておく。</p>
<p>そろそろだれかテンプレートエンジンを標準化してほしい。</p>
<div class="toc">
<ul>
<li><a href="#_1">基本</a></li>
<li><a href="#_2">変数展開</a></li>
<li><a href="#_3">関数呼び出し</a></li>
<li><a href="#_4">ループ</a></li>
<li><a href="#_5">組み込み関数</a></li>
</ul>
</div>
<h2 id="_1">基本</h2>
<div class="pygments_borland"><pre><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
    <span class="s">&quot;os&quot;</span>
    <span class="s">&quot;text/template&quot;</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">tmpl</span> <span class="p">:=</span> <span class="s">&quot;Hello, {{.template}}!&quot;</span>
    <span class="n">t</span> <span class="p">:=</span> <span class="n">template</span><span class="p">.</span><span class="n">New</span><span class="p">(</span><span class="s">&quot;t&quot;</span><span class="p">)</span>
    <span class="n">template</span><span class="p">.</span><span class="n">Must</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">tmpl</span><span class="p">))</span>
    <span class="n">t</span><span class="p">.</span><span class="n">Execute</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">Stdout</span><span class="p">,</span> <span class="k">map</span><span class="p">[</span><span class="nb">string</span><span class="p">]</span><span class="nb">string</span><span class="p">{</span><span class="s">&quot;template&quot;</span><span class="p">:</span> <span class="s">&quot;World&quot;</span><span class="p">})</span>
<span class="p">}</span>
</pre></div>

<p>ちなみに、<code>template.Must(t.Parse(tmpl))</code>は以下のショートカット</p>
<div class="pygments_borland"><pre><span class="n">_</span><span class="p">,</span> <span class="n">err</span> <span class="p">:=</span> <span class="n">t</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">tmpl</span><span class="p">)</span>
<span class="k">if</span> <span class="n">err</span> <span class="p">!=</span> <span class="n">nil</span> <span class="p">{</span>
    <span class="n">panic</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>

<h2 id="_2">変数展開</h2>
<p>通常はmapのキーかstructのメンバを<code>.Key</code>のようにドット付きで指定するとでその値が展開される。
ただし、該当するキーが見つからなかった場合、mapでは<code>&lt;no value&gt;</code>という文字列が出力されるが、structではエラーになる。</p>
<div class="pygments_borland"><pre><span class="k">type</span> <span class="n">T</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">Name</span> <span class="nb">string</span>
<span class="p">}</span>

<span class="n">tmpl</span> <span class="p">:=</span> <span class="s">&quot;Hello, {{.Name}}!\n&quot;</span>
<span class="n">t</span> <span class="p">:=</span> <span class="n">template</span><span class="p">.</span><span class="n">New</span><span class="p">(</span><span class="s">&quot;t&quot;</span><span class="p">)</span>
<span class="n">template</span><span class="p">.</span><span class="n">Must</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">tmpl</span><span class="p">))</span>

<span class="n">t</span><span class="p">.</span><span class="n">Execute</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">Stdout</span><span class="p">,</span> <span class="k">map</span><span class="p">[</span><span class="nb">string</span><span class="p">]</span><span class="nb">string</span><span class="p">{</span><span class="s">&quot;Name&quot;</span><span class="p">:</span> <span class="s">&quot;map&quot;</span><span class="p">})</span>
<span class="n">t</span><span class="p">.</span><span class="n">Execute</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">Stdout</span><span class="p">,</span> <span class="n">T</span><span class="p">{</span><span class="n">Name</span><span class="p">:</span> <span class="s">&quot;struct&quot;</span><span class="p">})</span>
<span class="n">t</span><span class="p">.</span><span class="n">Execute</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">Stdout</span><span class="p">,</span> <span class="p">&amp;</span><span class="n">T</span><span class="p">{</span><span class="n">Name</span><span class="p">:</span> <span class="s">&quot;struct reference&quot;</span><span class="p">})</span>
</pre></div>

<p><code>.</code>のようにドットだけを渡すと変数それ自体が展開される。</p>
<div class="pygments_borland"><pre><span class="n">tmpl</span> <span class="p">:=</span> <span class="s">&quot;Hello, {{.}}!\n&quot;</span>
<span class="n">t</span> <span class="p">:=</span> <span class="n">template</span><span class="p">.</span><span class="n">New</span><span class="p">(</span><span class="s">&quot;t&quot;</span><span class="p">)</span>
<span class="n">template</span><span class="p">.</span><span class="n">Must</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">tmpl</span><span class="p">))</span>
<span class="n">t</span><span class="p">.</span><span class="n">Execute</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">Stdout</span><span class="p">,</span> <span class="s">&quot;World&quot;</span><span class="p">)</span>
</pre></div>

<h2 id="_3">関数呼び出し</h2>
<p>関数はシェルのパイプのように連結させて呼びだせる。テンプレート内で呼ぶ関数は<code>template.FuncMap</code>で渡す。</p>
<div class="pygments_borland"><pre><span class="n">tmpl</span> <span class="p">:=</span> <span class="s">`Now {{now}}, {{&quot;hello&quot; | toupper}}`</span>
<span class="n">t</span> <span class="p">:=</span> <span class="n">template</span><span class="p">.</span><span class="n">New</span><span class="p">(</span><span class="s">&quot;t&quot;</span><span class="p">)</span>
<span class="n">t</span><span class="p">.</span><span class="n">Funcs</span><span class="p">(</span><span class="n">template</span><span class="p">.</span><span class="n">FuncMap</span><span class="p">{</span>
    <span class="s">&quot;now&quot;</span><span class="p">:</span>     <span class="k">func</span><span class="p">()</span> <span class="nb">string</span> <span class="p">{</span> <span class="k">return</span> <span class="n">time</span><span class="p">.</span><span class="n">Now</span><span class="p">().</span><span class="n">String</span><span class="p">()</span> <span class="p">},</span>
    <span class="s">&quot;toupper&quot;</span><span class="p">:</span> <span class="n">strings</span><span class="p">.</span><span class="n">ToUpper</span><span class="p">,</span>
<span class="p">})</span>
<span class="n">template</span><span class="p">.</span><span class="n">Must</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">tmpl</span><span class="p">))</span>
<span class="n">t</span><span class="p">.</span><span class="n">Execute</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">Stdout</span><span class="p">,</span> <span class="n">nil</span><span class="p">)</span> <span class="c1">// =&gt; Now 2013-11-19 19:17:51.378063751 +0900 JST, HELLO</span>
</pre></div>

<h2 id="_4">ループ</h2>
<p>組み込みの<code>range</code> Actionをつかえばよい。</p>
<div class="pygments_borland"><pre><span class="k">type</span> <span class="n">T</span> <span class="k">struct</span><span class="p">{</span> <span class="n">Name</span> <span class="nb">string</span> <span class="p">}</span>
<span class="n">tmpl</span> <span class="p">:=</span> <span class="s">`</span>
<span class="s">{{range .}}- {{.Name}}</span>
<span class="s">{{end}}</span>
<span class="s">`</span>
<span class="n">t</span> <span class="p">:=</span> <span class="n">template</span><span class="p">.</span><span class="n">New</span><span class="p">(</span><span class="s">&quot;t&quot;</span><span class="p">)</span>
<span class="n">template</span><span class="p">.</span><span class="n">Must</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">tmpl</span><span class="p">))</span>
<span class="n">t</span><span class="p">.</span><span class="n">Execute</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">Stdout</span><span class="p">,</span> <span class="p">[]</span><span class="n">T</span><span class="p">{</span>
    <span class="p">{</span><span class="n">Name</span><span class="p">:</span> <span class="s">&quot;Alice&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="n">Name</span><span class="p">:</span> <span class="s">&quot;Bob&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="n">Name</span><span class="p">:</span> <span class="s">&quot;Charlie&quot;</span><span class="p">},</span>
    <span class="p">{</span><span class="n">Name</span><span class="p">:</span> <span class="s">&quot;Dave&quot;</span><span class="p">},</span>
<span class="p">})</span>
</pre></div>

<p>その他、条件分岐等のActionは <a href="http://golang.org/pkg/text/template/#hdr-Actions">マニュアルのActionsの</a> 参照</p>
<h2 id="_5">組み込み関数</h2>
<p>こちらも <a href="http://golang.org/pkg/text/template/#hdr-Functions">マニュアルのFunctionsの項</a> を参照</p>]]></content:encoded>
    </item>
    <item>
      <title>GoConveyでGoプロジェクトをブラウザからテストする</title>
      <link>http://mojavy.com/blog/2013/11/17/goconvey/</link>
      <pubDate>Sun, 17 Nov 2013 00:30:57 JST</pubDate>
      <category><![CDATA[golang]]></category>
      <guid isPermaLink="true">http://mojavy.com/blog/2013/11/17/goconvey/</guid>
      <description>GoConveyでGoプロジェクトをブラウザからテストする</description>
      <content:encoded><![CDATA[<p><a href="http://smartystreets.github.io/goconvey/">GoConvey</a> を試してみたらなかなかよかったので紹介します。</p>
<h2 id="_1">目次</h2>
<div class="toc">
<ul>
<li><a href="#_1">目次</a></li>
<li><a href="#goconvey">goconveyとは</a></li>
<li><a href="#_2">クイックスタート</a></li>
<li><a href="#_3">テストを書く</a></li>
<li><a href="#_4">ターミナルから自動テスト</a></li>
<li><a href="#tips">tips</a></li>
<li><a href="#_5">まとめ</a></li>
<li><a href="#_6">その他参考</a></li>
</ul>
</div>
<h2 id="goconvey">goconveyとは</h2>
<p>gopherのためのかっこいいテストツールです。以下のような特徴があります。</p>
<ul>
<li><code>go test</code>をそのまま実行できる</li>
<li>リグレッションテストのための一式</li>
<li>見やすく色付けされた出力</li>
<li>完全に自動化されたWeb UI</li>
<li>テストコードジェネレータ</li>
<li>デスクトップ通知</li>
<li>ターミナル上で動く自動テストスクリプト</li>
<li>Sublime Textとの連携</li>
</ul>
<h2 id="_2">クイックスタート</h2>
<div class="pygments_borland"><pre>$ go get github.com/smartystreets/goconvey # install
$ $GOPATH/bin/goconvey
</pre></div>

<p>上記コマンドを実行して <code>http://localhost:8080</code> にブラウザからWeb UIアクセスすると、goconveyを起動したディレクトリ以下のファイルの更新を自動的に検知してテストを起動してくれます。</p>
<p>Web UIの右上にあるベルのアイコンをクリックすると、デスクトップ通知も有効にできます。</p>
<p>また、テストが失敗した場合はその部分をクリックすることで、Sublime Textで直接そこにジャンプできます。<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>
<p>特定のディレクトリ以下のテストを実行しないようにすることもできます。テストに時間がかかるような大きなプロジェクトでも適当に必要なところだけ有効にできるので、ストレスがたまりにくいと思います。</p>
<h2 id="_3">テストを書く</h2>
<p>goconveyのWeb UIは<code>go test</code>で起動できるテストならなんにでも使えますが<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> 、goconveyのテスティングフレームワークをつかうとさらにわかりやすい結果を出力できます。</p>
<div class="pygments_borland"><pre><span class="k">package</span> <span class="n">goconveytest</span>

<span class="k">import</span> <span class="p">(</span>
    <span class="p">.</span> <span class="s">&quot;github.com/smartystreets/goconvey/convey&quot;</span>
    <span class="s">&quot;testing&quot;</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">TestSpec</span><span class="p">(</span><span class="n">t</span> <span class="p">*</span><span class="n">testing</span><span class="p">.</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">x</span> <span class="nb">int</span>

    <span class="c1">// Only pass t into top-level Convey calls</span>
    <span class="n">Convey</span><span class="p">(</span><span class="s">&quot;Given some integer with a starting value&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">x</span> <span class="p">=</span> <span class="mi">1</span>

        <span class="n">Convey</span><span class="p">(</span><span class="s">&quot;When the integer is incremented&quot;</span><span class="p">,</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">x</span><span class="p">++</span>

            <span class="n">Convey</span><span class="p">(</span><span class="s">&quot;The value should be greater by one&quot;</span><span class="p">,</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">So</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ShouldEqual</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">})</span>
        <span class="p">})</span>
    <span class="p">})</span>
<span class="p">}</span>
</pre></div>

<p>Web UIから文章を入力することでテストコードをある程度自動生成することもできます。</p>
<p>BDDスタイルはあんまり得意ではないので詳細は省略します。</p>
<h2 id="_4">ターミナルから自動テスト</h2>
<p>ブラウザなんて立ちあげたくない硬派な人向けにターミナルでファイル監視してテストを起動できるスクリプトも提供されています。
emacsのロックファイルがあると落ちてしまう問題があったのですが、さっきpull requestだしたらすぐマージしてくれました。 <a href="https://github.com/smartystreets/goconvey/pull/88">https://github.com/smartystreets/goconvey/pull/88</a> </p>
<div class="pygments_borland"><pre>$GOPATH/src/github.com/smartystreets/goconvey/scripts/idle.py -v
</pre></div>

<h2 id="tips">tips</h2>
<ul>
<li><code>localhost:8080/latest</code>にアクセスするとjsonでテスト結果がとれます</li>
<li>goconveyのWeb UIは<code>GOPATH</code>以下のパッケージのディレクトリで起動する必要があります (例えば、<code>$GOPATH/src/github.com/yourname/packagename</code>)</li>
</ul>
<h2 id="_5">まとめ</h2>
<p>goconveyを簡単に紹介しました。Web UIだけでも試す価値はあると思います。</p>
<p>ビデオでの解説もあります。ぶっちゃけこの記事を読むより動画を見たほうが早いです。</p>
<iframe width="420" height="315" src="//www.youtube.com/embed/vL_UD1oAF0E" frameborder="0" allowfullscreen></iframe>

<h2 id="_6">その他参考</h2>
<ul>
<li><a href="http://qiita.com/takuan_osho/items/51c8856a3d28145d87bc">http://qiita.com/takuan_osho/items/51c8856a3d28145d87bc</a> </li>
<li><a href="http://blog.satotaichi.info/testingframeworks-for-golang">http://blog.satotaichi.info/testingframeworks-for-golang</a> </li>
</ul>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>残念なことにemacsやvimには対応していない&#160;<a href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>ginkgoやtestifyのテストも実行できます。ただし、ginkgoのテスト結果はデフォルトだとエスケープシーケンスがそのまま表示されてしまいます&#160;<a href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
</ol>
</div>]]></content:encoded>
    </item>
    <item>
      <title>ベイズの定理から見るガン検査</title>
      <link>http://mojavy.com/blog/2013/11/12/bayes-theorem-and-detecting-cancer/</link>
      <pubDate>Tue, 12 Nov 2013 03:01:16 JST</pubDate>
      <category><![CDATA[statistics]]></category>
      <guid isPermaLink="true">http://mojavy.com/blog/2013/11/12/bayes-theorem-and-detecting-cancer/</guid>
      <description>ベイズの定理から見るガン検査</description>
      <content:encoded><![CDATA[<p><a href="http://www.huffingtonpost.jp/2013/11/10/cancer-test_n_4252707.html">http://www.huffingtonpost.jp/2013/11/10/cancer-test_n_4252707.html</a> </p>
<p>高校生がすい臓がん発見の画期的方法を開発したという記事が話題になってます。</p>
<p>この検査法の改善が統計的にどういう意味をもつのか実際にベイズの定理をつかって計算してみます。</p>
<p>ここでは以下のような問題を考えることとします。</p>
<blockquote>
<p>あるガン検査法は、被験者ががんの場合はp1の確率で陽性になり、被験者ががんでなければp2の確率で陰性になります。被験者ががん患者である確率がp3のとき、がん患者が検査の結果実際に陽性だと判定される確率を求めなさい。</p>
</blockquote>
<p>Xを被検査者はガンであるという事象、Yを検査の結果が被検査者はガンであると示す事象として、それぞれ以下のように置き換えることができます。</p>
<p><img src="/images/874a5aeecf9b35cdbf1134ce65609eb8.png">
</p>

<p>
ただし、<img src="/images/33690e97dbeaa68d615e68dba167db2a.png"> はBが起こったときにAが起こる確率(条件付き確率)、<img src="/images/f679168b61f35c21700eef5eb88dc82d.png"> はAが起こらないという事象(補事象)を表します。
</p>

<p>求めたい確率は<img src="/images/7082016653a57c45dae6f7d57ceea8ba.png"> なので、ベイズの定理より
<p><img src="/images/227eb2fa21aa259a48119a03e888a78c.png">
</p></p>
<p>ここで<img src="/images/0c3d72395d7576ab13b9e9389f865960.png"> は検査結果が真陽性となる確率と偽陰性となる確率を足したものなので、
<p><img src="/images/e2fb081253f2ada10b84e8c39da103d6.png">
</p></p>
<p>また、
<p><img src="/images/18b3d7224708203cb4000f3539856aab.png"> 
</p>
なので、</p>
<p><img src="/images/298c37b1f601ada40fbe0808816d66a3.png"> 
</p>

<p>となります。</p>
<p>以上の結果に実際に値をあてはめてみます。</p>
<p>2008年のすい臓がん推定患者数は29584 <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>、同年の人口は127692000 <sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>なので、<code>p3=0.23168 * 10^-3</code>。
また、簡単のためにp1, p2をひとまとめに誤検出の確率と仮定して<code>p1=p2=q</code>おくと、P(Y|X)が70%となるようなqは、<strong>q=0.99990</strong>となります。</p>
<p>このことから、99.99%の精度をもつ検出方法でも実際には30%も見逃してしまうということがわかります。</p>
<p>さらに、「400倍の精度で検査できる」という部分を誤検出の確率が400分の1になったという意味だと解釈して、
<code>q'=1-(1-q)/400</code>とおいてがん患者が検査の結果実際に陽性だと判定される確率を再度計算すると<strong>P(Y|X)=0.99892</strong>となります。</p>
<p>つまり30%見逃していたのが1%程度まで減ったということです。
これはすばらしい成果といえるのではないでしょうか。</p>
<p>最初は30%も見逃すとかどんなひどい検査だったんだ、などと思ってしまうかもしれませんが、上記の計算で実際はそれほど単純な話ではないことがわかると思います。</p>
<p><a href="http://www.amazon.co.jp/gp/product/4130420658/ref=as_li_ss_il?ie=UTF8&camp=247&creative=7399&creativeXSIN=4130420658&linkCode=as2&tag=armyofpigs-22"><img border="0" src="http://ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&ASIN=4130420658&Format=_SL160_&ID=AsinImage&MarketPlace=JP&ServiceVersion=20070822&WS=1&tag=armyofpigs-22" ></a><img src="http://ir-jp.amazon-adsystem.com/e/ir?t=armyofpigs-22&l=as2&o=9&a=4130420658" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> <sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> </p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p><a href="http://ganjoho.jp/professional/statistics/statistics.html">国立がん研究センターがん対策情報センター - http://ganjoho.jp/professional/statistics/statistics.html</a> &#160;<a href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p><a href="http://www.e-stat.go.jp/SG1/estat/List.do?lid=000001054002">http://www.e-stat.go.jp/SG1/estat/List.do?lid=000001054002</a> &#160;<a href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:3">
<p>この問題は統計学入門の練習問題4.7を参考にしています。&#160;<a href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
</ol>
</div>]]></content:encoded>
    </item>
    <item>
      <title>R Tutorial Part2 Chapter08 (Numerical Measures)</title>
      <link>http://mojavy.com/blog/2013/10/28/r-tutor-chap08/</link>
      <pubDate>Mon, 28 Oct 2013 02:11:53 JST</pubDate>
      <category><![CDATA[note]]></category>
      <category><![CDATA[statistics]]></category>
      <category><![CDATA[R]]></category>
      <guid isPermaLink="true">http://mojavy.com/blog/2013/10/28/r-tutor-chap08/</guid>
      <description>R Tutorial Part2 Chapter08 (Numerical Measures)</description>
      <content:encoded><![CDATA[<p>これは<a href="http://www.r-tutor.com/elementary-statistics/numerical-measures">R Tutorial Part2 Chapter08 (Numerical Measures)</a> のノートです。
<a href="/slide/2013/10/26/r-tutor-chap08/">slideはこちら</a> 。</p>
<h3 id="mean-median">mean, median</h3>
<ul>
<li>mean: 平均</li>
<li>median: 中央値、中間値。データ数が偶数個の場合は前後の2つの数の平均。</li>
</ul>
<div class="pygments_borland"><pre>&gt; library(MASS)
&gt; mean(faithful$eruption)
[1] 3.487783
&gt; median(faithful$eruption)
[1] 4
</pre></div>

<h3 id="quartile-quantile-percentile">quartile, quantile, percentile</h3>
<ul>
<li>first quartile, lower quartile: ソートされたデータの数を１：３に分ける位置の値。 第１四分位</li>
<li>second quartile, median: 中間値</li>
<li>third quartile, upper quartile: 第３四分位</li>
<li>quantile: 変位値</li>
<li>percentile: 百分位数</li>
</ul>
<div class="pygments_borland"><pre>&gt; quantile(faithful$eruption)
     0%     25%     50%     75%    100% 
1.60000 2.16275 4.00000 4.45425 5.10000 
&gt; x = sort(faithful$eruption)
&gt; x[1+floor((length(x) - 1)/4)] + (x[1+ceiling((length(x) - 1)/4)] - x[1+floor((length(x) - 1)/4)]) * 3 / 4
[1] 2.16275
&gt; quantile(faithful$eruption, c(.32, .57, .98))
    32%     57%     98% 
2.39524 4.13300 4.93300 
</pre></div>

<h3 id="max-min-range">max, min, range</h3>
<div class="pygments_borland"><pre>&gt; max(faithful$eruption)
[1] 5.1
&gt; min(faithful$eruption)
[1] 1.6
&gt; max(faithful$eruption) - min(faithful$eruption)
[1] 3.5
</pre></div>

<h3 id="interquartile-range">interquartile range</h3>
<ul>
<li>interquartile range: 四分位範囲, upper quartile - lower quartile</li>
</ul>
<div class="pygments_borland"><pre>&gt; IQR(faithful$eruption)
[1] 2.2915
&gt; x = quantile(faithful$eruption)
&gt; x[4] - x[2]
   75% 
2.2915 
</pre></div>

<h3 id="box-plot">box plot</h3>
<ul>
<li>boxplot: 箱ひげ図</li>
</ul>
<div class="pygments_borland"><pre>&gt; boxplot(faithful$eruption, horizontal=TRUE)
</pre></div>

<p><img alt="boxplot" src="/images/numerical-measures4x.png" /> </p>
<p>※ 箱のなかの線はmedian</p>
<h3 id="variance-standard-deviation">variance, standard deviation</h3>
<ul>
<li>variance: 分散。Rのvar関数は<a href="http://www.sist.ac.jp/~kanakubo/research/statistic/fuhenbunsan.html">不偏分散</a> </li>
<li>standard deviation: 標準偏差</li>
</ul>
<div class="pygments_borland"><pre>&gt; var(faithful$eruption)
[1] 1.302728
&gt; sd(faithful$eruption)
[1] 1.141371

&gt; var2 &lt;- function(x) { sum((x - mean(x)) ^ 2) / length(x) }   # 普通の分散
&gt; var2(faithful$eruption)
[1] 1.297939
</pre></div>

<h3 id="covariance-correlation-coefficient">covariance, correlation coefficient</h3>
<ul>
<li>covariance: 共分散。2 組の対応するデータ間での、平均からの偏差の積の平均値。</li>
<li>correlation coefficient: 相関係数。共分散をそれぞれのデータの標準偏差の積で割ったもの。</li>
</ul>
<div class="pygments_borland"><pre>&gt; cov(faithful$eruption, faithful$waiting)
[1] 13.97781
&gt; cor(faithful$eruption, faithful$waiting)
[1] 0.9008112
</pre></div>

<p>correlation coefficientが1に近いほど正の相関があるといえる</p>
<h3 id="e1071">e1071</h3>
<blockquote>
<p>Functions for latent class analysis, short time Fourier transform, fuzzy clustering, support vector machines, shortest path computation, bagged clustering, naive Bayes classifier</p>
</blockquote>
<div class="pygments_borland"><pre>&gt; install.packages(&#39;e1071&#39;)
</pre></div>

<p><a href="http://cran.r-project.org/web/packages/e1071/index.html">http://cran.r-project.org/web/packages/e1071/index.html</a> </p>
<h3 id="central-moment">central moment</h3>
<ul>
<li>central moment： 中心積率。標本分散は2次のcentral moment</li>
</ul>
<div class="pygments_borland"><pre>&gt; library(e1071)
&gt; moment(faithful$eruption, order=3, center=TRUE)
[1] -0.6149059
</pre></div>

<h3 id="skewness-kurtosis">skewness, kurtosis</h3>
<ul>
<li>skewness: 歪度。対象性の度合いの指標。一般に、skewness &lt; 0 ならばmean &lt; median でそのデータの分散はleft skewed という。skewness &gt; 0 ならばmean &gt; median でright skewed という。</li>
<li>kurtosis: 尖度。分布の尖り具合の指標。kurtosis &lt; 0 ならフラットな分布になりplatykurtic(緩尖な)という。kurtosis &gt; 0ならとがった分布になりleptokurticという。正規分布の場合は0になりmesokurticという。</li>
</ul>
<div class="pygments_borland"><pre>&gt; skewness(faithful$eruption)
[1] -0.4135498
&gt; kurtosis(faithful$eruption)
[1] -1.511605
</pre></div>

<h3 id="misc">misc</h3>
<ul>
<li>この項は統計でよくつかう関数のまとめになってます</li>
<li>各関数の詳細はhelpを参照</li>
</ul>]]></content:encoded>
    </item>
    <item>
      <title>reveal.js をつかってブログ記事からスライドを生成する</title>
      <link>http://mojavy.com/blog/2013/10/18/revealjs/</link>
      <pubDate>Fri, 18 Oct 2013 22:00:24 JST</pubDate>
      <category><![CDATA[blog]]></category>
      <category><![CDATA[reveal.js]]></category>
      <category><![CDATA[blogofile]]></category>
      <guid isPermaLink="true">http://mojavy.com/blog/2013/10/18/revealjs/</guid>
      <description>reveal.js をつかってブログ記事からスライドを生成する</description>
      <content:encoded><![CDATA[<h3 id="_1">はじめに</h3>
<p>これは以下のような人を対象にしたポストです</p>
<ul>
<li class="fragment">スライドをmarkdownでつくりたい</li>
<li class="fragment">ブログはmarkdownでかいている</li>
<li class="fragment">ずぼらするためには努力を惜しまない</li>
</ul>

<h3 id="_2">デモ</h3>
<p>とりあえず以下のスライドをみてください。</p>
<ul>
<li><a href="/slide/2013/10/18/revealjs/">/slide/2013/10/18/revealjs/</a> </li>
</ul>
<h3 id="revealjs">reveal.jsとは</h3>
<p>HTMLでかけるプレゼンツールです。詳細は以下等を参照してください。</p>
<ul>
<li><a href="http://lab.hakim.se/reveal-js">http://lab.hakim.se/reveal-js/</a> </li>
</ul>
<h3 id="static-cms">static CMS</h3>
<p>説明は省略します。このブログはblogofileでできていますが、jekyllやhakyllのようなものでもほぼ同等なことができます。</p>
<ul>
<li><a href="http://jekyllrb.com/">http://jekyllrb.com/</a> </li>
<li><a href="http://www.blogofile.com/">http://www.blogofile.com/</a> </li>
<li><a href="http://jaspervdj.be/hakyll/">http://jaspervdj.be/hakyll/</a> </li>
</ul>
<h3 id="_3">やり方</h3>
<p>reveal.jsのmarkdown埋め込み機能をつかうだけです。reveal.jsのREADMEを読むとめんどうなように見えますが、 <a href="https://github.com/taksatou/taksatou.github.com/blob/master/_blogofile/_templates/revealjs.mako">revealjs.mako</a>  のようにテンプレートを書くだけ。とはいえ多少のコーディングが必要です。</p>
<p>詳細は以下のソースをみてください。</p>
<ul>
<li><a href="https://github.com/taksatou/taksatou.github.com/blob/master/_blogofile/_templates/revealjs.mako">revealjs.mako</a> </li>
<li><a href="https://github.com/taksatou/taksatou.github.com/blob/master/_blogofile/_controllers/blog/slide.py">slide.py</a> </li>
</ul>
<h2 id="code-highlight">code highlight</h2>
<p>コードハイライトつかえます。</p>
<div class="pygments_borland"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="c1">// highlight test</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;hello, world!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<h3 id="fragment">fragment</h3>
<p>fragmentもつかえます。</p>
<p class="fragment">... to step through ...</p>

<ol>
<li class="fragment"><code>any type</code></li>
<li class="fragment"><em>of view</em></li>
<li class="fragment"><strong>fragments</strong></li>
</ol>

<h3 id="_4">長所</h3>
<ul>
<li class="fragment">ブログ書くついてでにスライドもできる</li>
<li class="fragment">スライドの共有が簡単</li>
<li class="fragment">パワポ不要</li>
<li class="fragment">さりげなくギークっぽさがアピールできる</li>
</ul>

<h3 id="_5">短所</h3>
<ul>
<li class="fragment">ブログとスライドのそれぞれの完成度を両立した記事にまとめるのは難しい</li>
<li class="fragment">多少はhtmlを書く必要があるときもある</li>
</ul>

<h3 id="_6">まとめ</h3>
<ul>
<li class="fragment">blogofileにreveal.jsを組み込んだ話を紹介しました</li>
<li class="fragment">reveal.jsかっこいいです</li>
</ul>]]></content:encoded>
    </item>
    <item>
      <title>オーバーフローしにくい組み合わせの数の計算方法</title>
      <link>http://mojavy.com/blog/2013/10/17/calculate-combinations/</link>
      <pubDate>Thu, 17 Oct 2013 21:13:58 JST</pubDate>
      <category><![CDATA[algorithms]]></category>
      <category><![CDATA[programming]]></category>
      <guid isPermaLink="true">http://mojavy.com/blog/2013/10/17/calculate-combinations/</guid>
      <description>オーバーフローしにくい組み合わせの数の計算方法</description>
      <content:encoded><![CDATA[<p>Cで組み合わせの数を計算するときに定義通り計算するとすぐにオーバーフローしてしまう。
例えば以下のような実装だと、<img src="/images/cca79b0e713c769c64899333d0fe43e6.png"> 程度でも結果がおかしくなってしまう。</p>
<div class="pygments_borland"><pre><span class="cp">#include &lt;iostream&gt;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="n">uint64_t</span> <span class="n">fac</span><span class="p">(</span><span class="n">uint64_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">fac</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">uint64_t</span> <span class="n">combinations</span><span class="p">(</span><span class="n">uint64_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">uint64_t</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">fac</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">fac</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">fac</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">k</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">combinations</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// =&gt; 10</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">combinations</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// =&gt; 252</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">combinations</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// =&gt; 184756</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">combinations</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// =&gt; 0 !?</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>とりあえず素因数分解してやれば解決するのでいままでそうしてたのだけど、もっとかっこいい方法がないものかと思って探してみたらKnuth先生の本で以下のようなアルゴリズムが紹介されているらしい。<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 
これはかっこいい。</p>
<div class="pygments_borland"><pre><span class="n">uint64_t</span> <span class="n">combinations2</span><span class="p">(</span><span class="n">uint64_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">uint64_t</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uint64_t</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">uint64_t</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">;</span> <span class="o">++</span><span class="n">d</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">r</span> <span class="o">*=</span> <span class="n">n</span><span class="o">--</span><span class="p">;</span>
        <span class="n">r</span> <span class="o">/=</span> <span class="n">d</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">combinations2</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// =&gt; 155117520</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">combinations2</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// =&gt; 118264581564861424</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">combinations2</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// これはオーバーフローする</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>結果の値が範囲内ならオーバーフローしないのか、というとそういうわけではないけどナイーブな実装に比べるとずっと計算できる範囲が広いので、値のレンジがあらかじめわかっているのであればこれで十分ですね。</p>
<iframe src="http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=armyofpigs-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=4756145434" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>

<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p><a href="http://stackoverflow.com/questions/1838368/calculating-the-amount-of-combinations">http://stackoverflow.com/questions/1838368/calculating-the-amount-of-combinations</a>   残念ながらvol2は手元にはない&#160;<a href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>]]></content:encoded>
    </item>
    <item>
      <title>mustache基礎文法最速マスター</title>
      <link>http://mojavy.com/blog/2013/10/01/mustache-quick-master/</link>
      <pubDate>Tue, 01 Oct 2013 00:08:09 JST</pubDate>
      <category><![CDATA[ruby]]></category>
      <category><![CDATA[mustache]]></category>
      <guid isPermaLink="true">http://mojavy.com/blog/2013/10/01/mustache-quick-master/</guid>
      <description>mustache基礎文法最速マスター</description>
      <content:encoded><![CDATA[<p><img alt="mustache" src="/images/mustache-logo-250.png" /> </p>
<p>mustacheはシンプルなテンプレートエンジンなので本家の英語マニュアル <a href="http://mustache.github.io/mustache.5.html">mustache(5)</a> を見ても大したことはないですが、日本語情報の需要もそれなりにあると思うのでまとめておきます。</p>
<p>以下の内容はrubygemの<code>mustache-0.99.4</code>で確認しています。
他の言語の場合は適宜置きかえてください。</p>
<h2 id="_1">目次</h2>
<div class="toc">
<ul>
<li><a href="#_1">目次</a></li>
<li><a href="#_2">変数の展開</a></li>
<li><a href="#_3">変数のエスケープ</a></li>
<li><a href="#_4">条件分岐</a></li>
<li><a href="#_5">ループ</a></li>
<li><a href="#lambda">無名関数 (Lambda)</a></li>
<li><a href="#_6">コメント</a></li>
<li><a href="#_7">まとめ</a></li>
</ul>
</div>
<h2 id="_2">変数の展開</h2>
<p><code>{{name}}</code>のように2つのブレースで囲ったタグは、<code>name</code>という名前のキーの値でおきかえられます。</p>
<p>対応するキーが見つからなかった場合はデフォルトでは空文字になります。</p>
<div class="pygments_borland"><pre><span class="no">Mustache</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="s2">&quot;Hello, {{world}}!&quot;</span><span class="p">,</span> <span class="n">world</span><span class="p">:</span> <span class="s2">&quot;mustache&quot;</span><span class="p">)</span> <span class="c1"># =&gt; &quot;Hello, mustache!&quot;</span>
<span class="no">Mustache</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="s2">&quot;{{no_such_key}}&quot;</span><span class="p">)</span> <span class="c1"># =&gt; &quot;&quot;</span>
</pre></div>

<h2 id="_3">変数のエスケープ</h2>
<p>デフォルトではHTMLエスケープが有効になります。アンエスケープされたHTMLが使いたい場合は<code>{{{name}}}</code>のように3つのブレースで囲います。</p>
<div class="pygments_borland"><pre><span class="no">Mustache</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="s2">&quot;{{html}}&quot;</span><span class="p">,</span>  <span class="n">html</span><span class="p">:</span> <span class="s2">&quot;&lt;b&gt;GitHub&lt;/b&gt;&quot;</span><span class="p">)</span> <span class="c1"># =&gt; &quot;&amp;lt;b&amp;gt;GitHub&amp;lt;/b&amp;gt;&quot;</span>
<span class="no">Mustache</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="s2">&quot;{{{html}}}&quot;</span><span class="p">,</span> <span class="n">html</span><span class="p">:</span> <span class="s2">&quot;&lt;b&gt;GitHub&lt;/b&gt;&quot;</span><span class="p">)</span> <span class="c1"># =&gt; &quot;&lt;b&gt;GitHub&lt;/b&gt;&quot;</span>
</pre></div>

<h2 id="_4">条件分岐</h2>
<p><code>{{#name}} ... {{/name}}</code>のように、2つのタグに<code>#</code>と<code>/</code>をそれぞれつけたタグで囲われたブロックはセクションといいます。</p>
<p>セクションのキーに対応する値にbool値を渡せばif文のような使い方ができます。
<code>#</code>のかわりに<code>^</code>をつかうと真偽を反転できます。</p>
<div class="pygments_borland"><pre><span class="n">template</span> <span class="o">=</span> <span class="o">&lt;&lt;</span><span class="no">DOC</span>
<span class="sh">{{#condition}}</span>
<span class="sh">It is true.</span>
<span class="sh">{{/condition}}</span>
<span class="sh">{{^condition}}</span>
<span class="sh">No not true.</span>
<span class="sh">{{/condition}}</span>
<span class="no">DOC</span>
<span class="no">Mustache</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">condition</span><span class="p">:</span> <span class="kp">true</span><span class="p">)</span> <span class="c1"># =&gt; &quot;It is true.\n&quot;</span>
<span class="no">Mustache</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">condition</span><span class="p">:</span> <span class="kp">false</span><span class="p">)</span> <span class="c1"># =&gt; &quot;No not true.\n&quot;</span>
</pre></div>

<h2 id="_5">ループ</h2>
<p>セクションのキーに対応する値に配列を渡した場合は、それぞれの要素を引数として中のブロックが繰り返し評価されます。</p>
<div class="pygments_borland"><pre><span class="n">template</span> <span class="o">=</span> <span class="o">&lt;&lt;</span><span class="no">DOC</span>
<span class="sh">{{#animals}}</span>
<span class="sh">{{name}}</span>
<span class="sh">{{/animals}}</span>
<span class="no">DOC</span>
<span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="n">animals</span><span class="p">:</span> <span class="o">[</span><span class="p">{</span><span class="nb">name</span><span class="p">:</span> <span class="s2">&quot;cat&quot;</span><span class="p">},</span> <span class="p">{</span><span class="nb">name</span><span class="p">:</span> <span class="s2">&quot;dog&quot;</span><span class="p">},</span> <span class="p">{</span><span class="nb">name</span><span class="p">:</span> <span class="s2">&quot;pig&quot;</span><span class="p">}</span><span class="o">]</span><span class="p">}</span>
<span class="no">Mustache</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="c1"># =&gt; &quot;cat\ndog\npig\n&quot;</span>
</pre></div>

<h2 id="lambda">無名関数 (Lambda)</h2>
<p>セクションのキーに対応する値に呼び出し可能なオブジェクトを渡した場合は、そのブロック内のテキストを引数として実行され、その返り値が結果として出力されます。</p>
<div class="pygments_borland"><pre><span class="n">template</span> <span class="o">=</span> <span class="o">&lt;&lt;</span><span class="no">DOC</span>
<span class="sh">{{#proc}}</span>
<span class="sh">mojavy is bad</span>
<span class="sh">{{/proc}}</span>
<span class="no">DOC</span>
<span class="no">Mustache</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="nb">proc</span><span class="p">:</span> <span class="o">-&gt;</span><span class="n">text</span><span class="p">{</span><span class="n">text</span><span class="o">.</span><span class="n">gsub</span><span class="p">(</span><span class="sr">/bad/</span><span class="p">,</span> <span class="s1">&#39;nice&#39;</span><span class="p">)})</span> <span class="c1"># =&gt; &quot;mojavy is nice\n&quot;</span>
</pre></div>

<h2 id="_6">コメント</h2>
<p><code>!</code>をつけるとコメントになります</p>
<div class="pygments_borland"><pre><span class="no">Mustache</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="s2">&quot;Comment here: {{! ignore me }}&quot;</span><span class="p">)</span> <span class="c1"># =&gt; &quot;Comment here: &quot;</span>
</pre></div>

<h2 id="_7">まとめ</h2>
<p>mustacheの基本的な機能について簡単なサンプルコードとともに解説しました。
ここではrubyのmustacheを使用しましたが、他の言語でも同様の機能が使えます。
一部の機能については省略しているので、より詳細な情報については本家ドキュメントを参照してください。</p>]]></content:encoded>
    </item>
    <item>
      <title>debianパッケージをchefで削除する場合はpurgeを使う方がよい</title>
      <link>http://mojavy.com/blog/2013/09/10/chef-purge-package/</link>
      <pubDate>Tue, 10 Sep 2013 19:39:49 JST</pubDate>
      <category><![CDATA[chef]]></category>
      <category><![CDATA[ruby]]></category>
      <category><![CDATA[debian]]></category>
      <guid isPermaLink="true">http://mojavy.com/blog/2013/09/10/chef-purge-package/</guid>
      <description>debianパッケージをchefで削除する場合はpurgeを使う方がよい</description>
      <content:encoded><![CDATA[<p>apt-getコマンドにはパッケージを削除するためのコマンドが2種類ある</p>
<ul>
<li>remove: パッケージを削除するが設定ファイルはそのまま残す</li>
<li>purge: パッケージを削除するとき設定ファイルも削除する</li>
</ul>
<p>chefをつかっているということは設定ファイルもchefで管理しているはずなので、設定ファイルを残す必要はない。
さらに、依存で入ったパッケージも一緒に削除されるように、<code>options "--auto-remove"</code>などとしてやるとよい。</p>
<p>ゴミは混乱の元なので早めに消すべし。</p>]]></content:encoded>
    </item>
  </channel>
</rss>
