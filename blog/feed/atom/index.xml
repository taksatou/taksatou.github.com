<?xml version="1.0" encoding="UTF-8"?>
<feed
  xmlns="http://www.w3.org/2005/Atom"
  xmlns:thr="http://purl.org/syndication/thread/1.0"
  xml:lang="en"
   >
  <title type="text">mojavy.com</title>
  <subtitle type="text"></subtitle>

  <updated>2013-11-12T03:01:16Z</updated>
  <generator uri="http://blogofile.com/">Blogofile</generator>

  <link rel="alternate" type="text/html" href="http://mojavy.com/blog" />
  <id>http://mojavy.com/blog/feed/atom/</id>
  <link rel="self" type="application/atom+xml" href="http://mojavy.com/blog/feed/atom/" />
  <entry>
    <author>
      <name></name>
      <uri>http://mojavy.com/blog</uri>
    </author>
    <title type="html"><![CDATA[ベイズの定理から見るガン検査]]></title>
    <link rel="alternate" type="text/html" href="http://mojavy.com/blog/2013/11/12/bayes-theorem-and-detecting-cancer/" />
    <id>http://mojavy.com/blog/2013/11/12/bayes-theorem-and-detecting-cancer/</id>
    <updated>2013-11-12T03:01:16Z</updated>
    <published>2013-11-12T03:01:16Z</published>
    <category scheme="http://mojavy.com/blog" term="statistics" />
    <summary type="html"><![CDATA[ベイズの定理から見るガン検査]]></summary>
    <content type="html" xml:base="http://mojavy.com/blog/2013/11/12/bayes-theorem-and-detecting-cancer/"><![CDATA[<p><a href="http://www.huffingtonpost.jp/2013/11/10/cancer-test_n_4252707.html">http://www.huffingtonpost.jp/2013/11/10/cancer-test_n_4252707.html</a> </p>
<p>高校生がすい臓がん発見の画期的方法を開発したという記事が話題になってます。<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> </p>
<p>この検査法の改善が統計的にどういう意味をもつのか実際にベイズの定理をつかって計算してみます。</p>
<p>ここでは以下のような問題を考えることとします。</p>
<blockquote>
<p>あるガン検査法は、被験者ががんの場合はp1の確率で陽性になり、被験者ががんでなければp2の確率で陰性になります。被験者ががん患者である確率がp3のとき、がん患者が検査の結果実際に陽性だと判定される確率を求めなさい。</p>
</blockquote>
<p>Xを被検査者はガンであるという事象、Yを検査の結果が被検査者はガンであると示す事象として、それぞれ以下のように置き換えることができます。</p>
<p><img src="/images/874a5aeecf9b35cdbf1134ce65609eb8.png">
</p>

<p>
ただし、<img src="/images/33690e97dbeaa68d615e68dba167db2a.png"> はBが起こったときにAが起こる確率(条件付き確率)、<img src="/images/f679168b61f35c21700eef5eb88dc82d.png"> はAが起こらないという事象(補事象)を表します。
</p>

<p>求めたい確率は<img src="/images/7082016653a57c45dae6f7d57ceea8ba.png"> なので、ベイズの定理より
<p><img src="/images/227eb2fa21aa259a48119a03e888a78c.png">
</p></p>
<p>ここで<img src="/images/0c3d72395d7576ab13b9e9389f865960.png"> は検査結果が真陽性となる確率と偽陰性となる確率を足したものなので、
<p><img src="/images/e2fb081253f2ada10b84e8c39da103d6.png">
</p></p>
<p>また、
<p><img src="/images/18b3d7224708203cb4000f3539856aab.png"> 
</p>
なので、</p>
<p><img src="/images/298c37b1f601ada40fbe0808816d66a3.png"> 
</p>

<p>となります。</p>
<p>以上の結果に実際に値をあてはめてみます。</p>
<p>2008年のすい臓がん推定患者数は29584 <sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>、同年の人口は127692000 <sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>なので、<code>p3=0.23168 * 10^-3</code>。
また、簡単のためにp1, p2をひとまとめに誤検出の確率と仮定して<code>p1=p2=q</code>おくと、P(Y|X)が70%となるようなqは、<strong>q=0.99990</strong>となります。</p>
<p>このことから、99.99%の精度をもつ検出方法でも実際には30%も見逃してしまうということがわかります。</p>
<p>さらに、「400倍の精度で検査できる」という部分を誤検出の確率が400分の1になったという意味だと解釈して、
<code>q'=1-(1-q)/400</code>とおいてがん患者が検査の結果実際に陽性だと判定される確率を再度計算すると<strong>P(Y|X)=0.99892</strong>となります。</p>
<p>つまり30%見逃していたのが1%程度まで減ったということです。
これはすばらしい成果といえるのではないでしょうか。</p>
<p>最初は30%も見逃すとかどんなひどい検査だったんだ、などと思ってしまうかもしれませんが、上記の計算で実際はそれほど単純な話ではないことがわかると思います。</p>
<p><a href="http://www.amazon.co.jp/gp/product/4130420658/ref=as_li_ss_il?ie=UTF8&camp=247&creative=7399&creativeXSIN=4130420658&linkCode=as2&tag=armyofpigs-22"><img border="0" src="http://ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&ASIN=4130420658&Format=_SL160_&ID=AsinImage&MarketPlace=JP&ServiceVersion=20070822&WS=1&tag=armyofpigs-22" ></a><img src="http://ir-jp.amazon-adsystem.com/e/ir?t=armyofpigs-22&l=as2&o=9&a=4130420658" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /> <sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup> </p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>TEDの講演での、気が狂いそうになりながらも8000の候補の中から4000個くらい調べたところで目的のタンパク質をみつけた、というくだりを聞くと研究者の大変さに思いをはせずにはいられません&#160;<a href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p><a href="http://ganjoho.jp/professional/statistics/statistics.html">国立がん研究センターがん対策情報センター - http://ganjoho.jp/professional/statistics/statistics.html</a> &#160;<a href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:3">
<p><a href="http://www.e-stat.go.jp/SG1/estat/List.do?lid=000001054002">http://www.e-stat.go.jp/SG1/estat/List.do?lid=000001054002</a> &#160;<a href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:4">
<p>この問題は統計学入門の練習問題4.7を参考にしています。&#160;<a href="#fnref:4" rev="footnote" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
</ol>
</div>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://mojavy.com/blog</uri>
    </author>
    <title type="html"><![CDATA[R Tutorial Part2 Chapter08 (Numerical Measures)]]></title>
    <link rel="alternate" type="text/html" href="http://mojavy.com/blog/2013/10/28/r-tutor-chap08/" />
    <id>http://mojavy.com/blog/2013/10/28/r-tutor-chap08/</id>
    <updated>2013-10-28T02:11:53Z</updated>
    <published>2013-10-28T02:11:53Z</published>
    <category scheme="http://mojavy.com/blog" term="note" />
    <category scheme="http://mojavy.com/blog" term="statistics" />
    <category scheme="http://mojavy.com/blog" term="R" />
    <summary type="html"><![CDATA[R Tutorial Part2 Chapter08 (Numerical Measures)]]></summary>
    <content type="html" xml:base="http://mojavy.com/blog/2013/10/28/r-tutor-chap08/"><![CDATA[<p>これは<a href="http://www.r-tutor.com/elementary-statistics/numerical-measures">R Tutorial Part2 Chapter08 (Numerical Measures)</a> のノートです。
<a href="/slide/2013/10/26/r-tutor-chap08/">slideはこちら</a> 。</p>
<h3 id="mean-median">mean, median</h3>
<ul>
<li>mean: 平均</li>
<li>median: 中央値、中間値。データ数が偶数個の場合は前後の2つの数の平均。</li>
</ul>
<div class="pygments_borland"><pre>&gt; library(MASS)
&gt; mean(faithful$eruption)
[1] 3.487783
&gt; median(faithful$eruption)
[1] 4
</pre></div>

<h3 id="quartile-quantile-percentile">quartile, quantile, percentile</h3>
<ul>
<li>first quartile, lower quartile: ソートされたデータの数を１：３に分ける位置の値。 第１四分位</li>
<li>second quartile, median: 中間値</li>
<li>third quartile, upper quartile: 第３四分位</li>
<li>quantile: 変位値</li>
<li>percentile: 百分位数</li>
</ul>
<div class="pygments_borland"><pre>&gt; quantile(faithful$eruption)
     0%     25%     50%     75%    100% 
1.60000 2.16275 4.00000 4.45425 5.10000 
&gt; x = sort(faithful$eruption)
&gt; x[1+floor((length(x) - 1)/4)] + (x[1+ceiling((length(x) - 1)/4)] - x[1+floor((length(x) - 1)/4)]) * 3 / 4
[1] 2.16275
&gt; quantile(faithful$eruption, c(.32, .57, .98))
    32%     57%     98% 
2.39524 4.13300 4.93300 
</pre></div>

<h3 id="max-min-range">max, min, range</h3>
<div class="pygments_borland"><pre>&gt; max(faithful$eruption)
[1] 5.1
&gt; min(faithful$eruption)
[1] 1.6
&gt; max(faithful$eruption) - min(faithful$eruption)
[1] 3.5
</pre></div>

<h3 id="interquartile-range">interquartile range</h3>
<ul>
<li>interquartile range: 四分位範囲, upper quartile - lower quartile</li>
</ul>
<div class="pygments_borland"><pre>&gt; IQR(faithful$eruption)
[1] 2.2915
&gt; x = quantile(faithful$eruption)
&gt; x[4] - x[2]
   75% 
2.2915 
</pre></div>

<h3 id="box-plot">box plot</h3>
<ul>
<li>boxplot: 箱ひげ図</li>
</ul>
<div class="pygments_borland"><pre>&gt; boxplot(faithful$eruption, horizontal=TRUE)
</pre></div>

<p><img alt="boxplot" src="/images/numerical-measures4x.png" /> </p>
<p>※ 箱のなかの線はmedian</p>
<h3 id="variance-standard-deviation">variance, standard deviation</h3>
<ul>
<li>variance: 分散。Rのvar関数は<a href="http://www.sist.ac.jp/~kanakubo/research/statistic/fuhenbunsan.html">不偏分散</a> </li>
<li>standard deviation: 標準偏差</li>
</ul>
<div class="pygments_borland"><pre>&gt; var(faithful$eruption)
[1] 1.302728
&gt; sd(faithful$eruption)
[1] 1.141371

&gt; var2 &lt;- function(x) { sum((x - mean(x)) ^ 2) / length(x) }   # 普通の分散
&gt; var2(faithful$eruption)
[1] 1.297939
</pre></div>

<h3 id="covariance-correlation-coefficient">covariance, correlation coefficient</h3>
<ul>
<li>covariance: 共分散。2 組の対応するデータ間での、平均からの偏差の積の平均値。</li>
<li>correlation coefficient: 相関係数。共分散をそれぞれのデータの標準偏差の積で割ったもの。</li>
</ul>
<div class="pygments_borland"><pre>&gt; cov(faithful$eruption, faithful$waiting)
[1] 13.97781
&gt; cor(faithful$eruption, faithful$waiting)
[1] 0.9008112
</pre></div>

<p>correlation coefficientが1に近いほど正の相関があるといえる</p>
<h3 id="e1071">e1071</h3>
<blockquote>
<p>Functions for latent class analysis, short time Fourier transform, fuzzy clustering, support vector machines, shortest path computation, bagged clustering, naive Bayes classifier</p>
</blockquote>
<div class="pygments_borland"><pre>&gt; install.packages(&#39;e1071&#39;)
</pre></div>

<p><a href="http://cran.r-project.org/web/packages/e1071/index.html">http://cran.r-project.org/web/packages/e1071/index.html</a> </p>
<h3 id="central-moment">central moment</h3>
<ul>
<li>central moment： 中心積率。標本分散は2次のcentral moment</li>
</ul>
<div class="pygments_borland"><pre>&gt; library(e1071)
&gt; moment(faithful$eruption, order=3, center=TRUE)
[1] -0.6149059
</pre></div>

<h3 id="skewness-kurtosis">skewness, kurtosis</h3>
<ul>
<li>skewness: 歪度。対象性の度合いの指標。一般に、skewness &lt; 0 ならばmean &lt; median でそのデータの分散はleft skewed という。skewness &gt; 0 ならばmean &gt; median でright skewed という。</li>
<li>kurtosis: 尖度。分布の尖り具合の指標。kurtosis &lt; 0 ならフラットな分布になりplatykurtic(緩尖な)という。kurtosis &gt; 0ならとがった分布になりleptokurticという。正規分布の場合は0になりmesokurticという。</li>
</ul>
<div class="pygments_borland"><pre>&gt; skewness(faithful$eruption)
[1] -0.4135498
&gt; kurtosis(faithful$eruption)
[1] -1.511605
</pre></div>

<h3 id="misc">misc</h3>
<ul>
<li>この項は統計でよくつかう関数のまとめになってます</li>
<li>各関数の詳細はhelpを参照</li>
</ul>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://mojavy.com/blog</uri>
    </author>
    <title type="html"><![CDATA[reveal.js をつかってブログ記事からスライドを生成する]]></title>
    <link rel="alternate" type="text/html" href="http://mojavy.com/blog/2013/10/18/revealjs/" />
    <id>http://mojavy.com/blog/2013/10/18/revealjs/</id>
    <updated>2013-10-18T22:00:24Z</updated>
    <published>2013-10-18T22:00:24Z</published>
    <category scheme="http://mojavy.com/blog" term="blog" />
    <category scheme="http://mojavy.com/blog" term="reveal.js" />
    <category scheme="http://mojavy.com/blog" term="blogofile" />
    <summary type="html"><![CDATA[reveal.js をつかってブログ記事からスライドを生成する]]></summary>
    <content type="html" xml:base="http://mojavy.com/blog/2013/10/18/revealjs/"><![CDATA[<h3 id="_1">はじめに</h3>
<p>これは以下のような人を対象にしたポストです</p>
<ul>
<li class="fragment">スライドをmarkdownでつくりたい</li>
<li class="fragment">ブログはmarkdownでかいている</li>
<li class="fragment">ずぼらするためには努力を惜しまない</li>
</ul>

<h3 id="_2">デモ</h3>
<p>とりあえず以下のスライドをみてください。</p>
<ul>
<li><a href="/slide/2013/10/18/revealjs/">/slide/2013/10/18/revealjs/</a> </li>
</ul>
<h3 id="revealjs">reveal.jsとは</h3>
<p>HTMLでかけるプレゼンツールです。詳細は以下等を参照してください。</p>
<ul>
<li><a href="http://lab.hakim.se/reveal-js">http://lab.hakim.se/reveal-js/</a> </li>
</ul>
<h3 id="static-cms">static CMS</h3>
<p>説明は省略します。このブログはblogofileでできていますが、jekyllやhakyllのようなものでもほぼ同等なことができます。</p>
<ul>
<li><a href="http://jekyllrb.com/">http://jekyllrb.com/</a> </li>
<li><a href="http://www.blogofile.com/">http://www.blogofile.com/</a> </li>
<li><a href="http://jaspervdj.be/hakyll/">http://jaspervdj.be/hakyll/</a> </li>
</ul>
<h3 id="_3">やり方</h3>
<p>reveal.jsのmarkdown埋め込み機能をつかうだけです。reveal.jsのREADMEを読むとめんどうなように見えますが、 <a href="https://github.com/taksatou/taksatou.github.com/blob/master/_blogofile/_templates/revealjs.mako">revealjs.mako</a>  のようにテンプレートを書くだけ。とはいえ多少のコーディングが必要です。</p>
<p>詳細は以下のソースをみてください。</p>
<ul>
<li><a href="https://github.com/taksatou/taksatou.github.com/blob/master/_blogofile/_templates/revealjs.mako">revealjs.mako</a> </li>
<li><a href="https://github.com/taksatou/taksatou.github.com/blob/master/_blogofile/_controllers/blog/slide.py">slide.py</a> </li>
</ul>
<h2 id="code-highlight">code highlight</h2>
<p>コードハイライトつかえます。</p>
<div class="pygments_borland"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="c1">// highlight test</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;hello, world!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<h3 id="fragment">fragment</h3>
<p>fragmentもつかえます。</p>
<p class="fragment">... to step through ...</p>

<ol>
<li class="fragment"><code>any type</code></li>
<li class="fragment"><em>of view</em></li>
<li class="fragment"><strong>fragments</strong></li>
</ol>

<h3 id="_4">長所</h3>
<ul>
<li class="fragment">ブログ書くついてでにスライドもできる</li>
<li class="fragment">スライドの共有が簡単</li>
<li class="fragment">パワポ不要</li>
<li class="fragment">さりげなくギークっぽさがアピールできる</li>
</ul>

<h3 id="_5">短所</h3>
<ul>
<li class="fragment">ブログとスライドのそれぞれの完成度を両立した記事にまとめるのは難しい</li>
<li class="fragment">多少はhtmlを書く必要があるときもある</li>
</ul>

<h3 id="_6">まとめ</h3>
<ul>
<li class="fragment">blogofileにreveal.jsを組み込んだ話を紹介しました</li>
<li class="fragment">reveal.jsかっこいいです</li>
</ul>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://mojavy.com/blog</uri>
    </author>
    <title type="html"><![CDATA[オーバーフローしにくい組み合わせの数の計算方法]]></title>
    <link rel="alternate" type="text/html" href="http://mojavy.com/blog/2013/10/17/calculate-combinations/" />
    <id>http://mojavy.com/blog/2013/10/17/calculate-combinations/</id>
    <updated>2013-10-17T21:13:58Z</updated>
    <published>2013-10-17T21:13:58Z</published>
    <category scheme="http://mojavy.com/blog" term="algorithms" />
    <category scheme="http://mojavy.com/blog" term="programming" />
    <summary type="html"><![CDATA[オーバーフローしにくい組み合わせの数の計算方法]]></summary>
    <content type="html" xml:base="http://mojavy.com/blog/2013/10/17/calculate-combinations/"><![CDATA[<p>Cで組み合わせの数を計算するときに定義通り計算するとすぐにオーバーフローしてしまう。
例えば以下のような実装だと、<img src="/images/cca79b0e713c769c64899333d0fe43e6.png"> 程度でも結果がおかしくなってしまう。</p>
<div class="pygments_borland"><pre><span class="cp">#include &lt;iostream&gt;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="n">uint64_t</span> <span class="n">fac</span><span class="p">(</span><span class="n">uint64_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">fac</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">uint64_t</span> <span class="n">combinations</span><span class="p">(</span><span class="n">uint64_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">uint64_t</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">fac</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">fac</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">fac</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">k</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">combinations</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// =&gt; 10</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">combinations</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// =&gt; 252</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">combinations</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// =&gt; 184756</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">combinations</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// =&gt; 0 !?</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>とりあえず素因数分解してやれば解決するのでいままでそうしてたのだけど、もっとかっこいい方法がないものかと思って探してみたらKnuth先生の本で以下のようなアルゴリズムが紹介されているらしい。<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 
これはかっこいい。</p>
<div class="pygments_borland"><pre><span class="n">uint64_t</span> <span class="n">combinations2</span><span class="p">(</span><span class="n">uint64_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">uint64_t</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uint64_t</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">uint64_t</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">;</span> <span class="o">++</span><span class="n">d</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">r</span> <span class="o">*=</span> <span class="n">n</span><span class="o">--</span><span class="p">;</span>
        <span class="n">r</span> <span class="o">/=</span> <span class="n">d</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">combinations2</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// =&gt; 155117520</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">combinations2</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// =&gt; 118264581564861424</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">combinations2</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// これはオーバーフローする</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>結果の値が範囲内ならオーバーフローしないのか、というとそういうわけではないけどナイーブな実装に比べるとずっと計算できる範囲が広いので、値のレンジがあらかじめわかっているのであればこれで十分ですね。</p>
<iframe src="http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=armyofpigs-22&o=9&p=8&l=as4&m=amazon&f=ifr&ref=ss_til&asins=4756145434" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>

<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p><a href="http://stackoverflow.com/questions/1838368/calculating-the-amount-of-combinations">http://stackoverflow.com/questions/1838368/calculating-the-amount-of-combinations</a>   残念ながらvol2は手元にはない&#160;<a href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://mojavy.com/blog</uri>
    </author>
    <title type="html"><![CDATA[mustache基礎文法最速マスター]]></title>
    <link rel="alternate" type="text/html" href="http://mojavy.com/blog/2013/10/01/mustache-quick-master/" />
    <id>http://mojavy.com/blog/2013/10/01/mustache-quick-master/</id>
    <updated>2013-10-01T00:08:09Z</updated>
    <published>2013-10-01T00:08:09Z</published>
    <category scheme="http://mojavy.com/blog" term="ruby" />
    <category scheme="http://mojavy.com/blog" term="mustache" />
    <summary type="html"><![CDATA[mustache基礎文法最速マスター]]></summary>
    <content type="html" xml:base="http://mojavy.com/blog/2013/10/01/mustache-quick-master/"><![CDATA[<p><img alt="mustache" src="/images/mustache-logo-250.png" /> </p>
<p>mustacheはシンプルなテンプレートエンジンなので本家の英語マニュアル <a href="http://mustache.github.io/mustache.5.html">mustache(5)</a> を見ても大したことはないですが、日本語情報の需要もそれなりにあると思うのでまとめておきます。</p>
<p>以下の内容はrubygemの<code>mustache-0.99.4</code>で確認しています。
他の言語の場合は適宜置きかえてください。</p>
<h2 id="_1">目次</h2>
<div class="toc">
<ul>
<li><a href="#_1">目次</a></li>
<li><a href="#_2">変数の展開</a></li>
<li><a href="#_3">変数のエスケープ</a></li>
<li><a href="#_4">条件分岐</a></li>
<li><a href="#_5">ループ</a></li>
<li><a href="#lambda">無名関数 (Lambda)</a></li>
<li><a href="#_6">コメント</a></li>
<li><a href="#_7">まとめ</a></li>
</ul>
</div>
<h2 id="_2">変数の展開</h2>
<p><code>{{name}}</code>のように2つのブレースで囲ったタグは、<code>name</code>という名前のキーの値でおきかえられます。</p>
<p>対応するキーが見つからなかった場合はデフォルトでは空文字になります。</p>
<div class="pygments_borland"><pre><span class="no">Mustache</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="s2">&quot;Hello, {{world}}!&quot;</span><span class="p">,</span> <span class="n">world</span><span class="p">:</span> <span class="s2">&quot;mustache&quot;</span><span class="p">)</span> <span class="c1"># =&gt; &quot;Hello, mustache!&quot;</span>
<span class="no">Mustache</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="s2">&quot;{{no_such_key}}&quot;</span><span class="p">)</span> <span class="c1"># =&gt; &quot;&quot;</span>
</pre></div>

<h2 id="_3">変数のエスケープ</h2>
<p>デフォルトではHTMLエスケープが有効になります。アンエスケープされたHTMLが使いたい場合は<code>{{{name}}}</code>のように3つのブレースで囲います。</p>
<div class="pygments_borland"><pre><span class="no">Mustache</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="s2">&quot;{{html}}&quot;</span><span class="p">,</span>  <span class="n">html</span><span class="p">:</span> <span class="s2">&quot;&lt;b&gt;GitHub&lt;/b&gt;&quot;</span><span class="p">)</span> <span class="c1"># =&gt; &quot;&amp;lt;b&amp;gt;GitHub&amp;lt;/b&amp;gt;&quot;</span>
<span class="no">Mustache</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="s2">&quot;{{{html}}}&quot;</span><span class="p">,</span> <span class="n">html</span><span class="p">:</span> <span class="s2">&quot;&lt;b&gt;GitHub&lt;/b&gt;&quot;</span><span class="p">)</span> <span class="c1"># =&gt; &quot;&lt;b&gt;GitHub&lt;/b&gt;&quot;</span>
</pre></div>

<h2 id="_4">条件分岐</h2>
<p><code>{{#name}} ... {{/name}}</code>のように、2つのタグに<code>#</code>と<code>/</code>をそれぞれつけたタグで囲われたブロックはセクションといいます。</p>
<p>セクションのキーに対応する値にbool値を渡せばif文のような使い方ができます。
<code>#</code>のかわりに<code>^</code>をつかうと真偽を反転できます。</p>
<div class="pygments_borland"><pre><span class="n">template</span> <span class="o">=</span> <span class="o">&lt;&lt;</span><span class="no">DOC</span>
<span class="sh">{{#condition}}</span>
<span class="sh">It is true.</span>
<span class="sh">{{/condition}}</span>
<span class="sh">{{^condition}}</span>
<span class="sh">No not true.</span>
<span class="sh">{{/condition}}</span>
<span class="no">DOC</span>
<span class="no">Mustache</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">condition</span><span class="p">:</span> <span class="kp">true</span><span class="p">)</span> <span class="c1"># =&gt; &quot;It is true.\n&quot;</span>
<span class="no">Mustache</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">condition</span><span class="p">:</span> <span class="kp">false</span><span class="p">)</span> <span class="c1"># =&gt; &quot;No not true.\n&quot;</span>
</pre></div>

<h2 id="_5">ループ</h2>
<p>セクションのキーに対応する値に配列を渡した場合は、それぞれの要素を引数として中のブロックが繰り返し評価されます。</p>
<div class="pygments_borland"><pre><span class="n">template</span> <span class="o">=</span> <span class="o">&lt;&lt;</span><span class="no">DOC</span>
<span class="sh">{{#animals}}</span>
<span class="sh">{{name}}</span>
<span class="sh">{{/animals}}</span>
<span class="no">DOC</span>
<span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="n">animals</span><span class="p">:</span> <span class="o">[</span><span class="p">{</span><span class="nb">name</span><span class="p">:</span> <span class="s2">&quot;cat&quot;</span><span class="p">},</span> <span class="p">{</span><span class="nb">name</span><span class="p">:</span> <span class="s2">&quot;dog&quot;</span><span class="p">},</span> <span class="p">{</span><span class="nb">name</span><span class="p">:</span> <span class="s2">&quot;pig&quot;</span><span class="p">}</span><span class="o">]</span><span class="p">}</span>
<span class="no">Mustache</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="c1"># =&gt; &quot;cat\ndog\npig\n&quot;</span>
</pre></div>

<h2 id="lambda">無名関数 (Lambda)</h2>
<p>セクションのキーに対応する値に呼び出し可能なオブジェクトを渡した場合は、そのブロック内のテキストを引数として実行され、その返り値が結果として出力されます。</p>
<div class="pygments_borland"><pre><span class="n">template</span> <span class="o">=</span> <span class="o">&lt;&lt;</span><span class="no">DOC</span>
<span class="sh">{{#proc}}</span>
<span class="sh">mojavy is bad</span>
<span class="sh">{{/proc}}</span>
<span class="no">DOC</span>
<span class="no">Mustache</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="nb">proc</span><span class="p">:</span> <span class="o">-&gt;</span><span class="n">text</span><span class="p">{</span><span class="n">text</span><span class="o">.</span><span class="n">gsub</span><span class="p">(</span><span class="sr">/bad/</span><span class="p">,</span> <span class="s1">&#39;nice&#39;</span><span class="p">)})</span> <span class="c1"># =&gt; &quot;mojavy is nice\n&quot;</span>
</pre></div>

<h2 id="_6">コメント</h2>
<p><code>!</code>をつけるとコメントになります</p>
<div class="pygments_borland"><pre><span class="no">Mustache</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="s2">&quot;Comment here: {{! ignore me }}&quot;</span><span class="p">)</span> <span class="c1"># =&gt; &quot;Comment here: &quot;</span>
</pre></div>

<h2 id="_7">まとめ</h2>
<p>mustacheの基本的な機能について簡単なサンプルコードとともに解説しました。
ここではrubyのmustacheを使用しましたが、他の言語でも同様の機能が使えます。
一部の機能については省略しているので、より詳細な情報については本家ドキュメントを参照してください。</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://mojavy.com/blog</uri>
    </author>
    <title type="html"><![CDATA[debianパッケージをchefで削除する場合はpurgeを使う方がよい]]></title>
    <link rel="alternate" type="text/html" href="http://mojavy.com/blog/2013/09/10/chef-purge-package/" />
    <id>http://mojavy.com/blog/2013/09/10/chef-purge-package/</id>
    <updated>2013-09-10T19:39:49Z</updated>
    <published>2013-09-10T19:39:49Z</published>
    <category scheme="http://mojavy.com/blog" term="chef" />
    <category scheme="http://mojavy.com/blog" term="ruby" />
    <category scheme="http://mojavy.com/blog" term="debian" />
    <summary type="html"><![CDATA[debianパッケージをchefで削除する場合はpurgeを使う方がよい]]></summary>
    <content type="html" xml:base="http://mojavy.com/blog/2013/09/10/chef-purge-package/"><![CDATA[<p>apt-getコマンドにはパッケージを削除するためのコマンドが2種類ある</p>
<ul>
<li>remove: パッケージを削除するが設定ファイルはそのまま残す</li>
<li>purge: パッケージを削除するとき設定ファイルも削除する</li>
</ul>
<p>chefをつかっているということは設定ファイルもchefで管理しているはずなので、設定ファイルを残す必要はない。
さらに、依存で入ったパッケージも一緒に削除されるように、<code>options "--auto-remove"</code>などとしてやるとよい。</p>
<p>ゴミは混乱の元なので早めに消すべし。</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://mojavy.com/blog</uri>
    </author>
    <title type="html"><![CDATA[chef soloでAuthenticationFailedといわれたときの対応]]></title>
    <link rel="alternate" type="text/html" href="http://mojavy.com/blog/2013/09/09/chef-solo-ssh-config/" />
    <id>http://mojavy.com/blog/2013/09/09/chef-solo-ssh-config/</id>
    <updated>2013-09-09T20:43:04Z</updated>
    <published>2013-09-09T20:43:04Z</published>
    <category scheme="http://mojavy.com/blog" term="chef" />
    <category scheme="http://mojavy.com/blog" term="ruby" />
    <summary type="html"><![CDATA[chef soloでAuthenticationFailedといわれたときの対応]]></summary>
    <content type="html" xml:base="http://mojavy.com/blog/2013/09/09/chef-solo-ssh-config/"><![CDATA[<p>公開鍵認証なホストに対してパスフレーズ入力無しでsshログインができるにもかかわらず、</p>
<div class="pygments_borland"><pre><span class="nv">$ </span>knife solo cook myhost
Running Chef on myhost...
Checking Chef version...
Enter the password <span class="k">for </span>username@myhost:
ERROR: Net::SSH::AuthenticationFailed: username
</pre></div>

<p>のようにいわれてchef soloの実行に失敗してしまうときがある。</p>
<p>パスフレーズ入力無しでsshできたということは、普通は以下のうちの少くとも1つは満たされている。</p>
<ol>
<li>ssh-agentに対象の秘密鍵が登録されている</li>
<li>デフォルトパス($HOME/.ssh/id_rsa とか)に対象のパスフレーズ無し秘密鍵が保存されている</li>
<li>ssh_configでパスフレーズ無し秘密鍵を指定している</li>
</ol>
<p>それなのに<code>AuthenticationFailed</code>失敗してしまうのは、Net:SSHがデフォルトでは公開鍵認証を試行しない場合があるため。 <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 
これを回避するには、ssh_configで<code>PubkeyAuthentication yes</code>を明示すればよい。</p>
<p>なお、<code>Net::SSH</code>がどのような動きをしているかは以下のスニペットを試すとよい。</p>
<div class="pygments_borland"><pre><span class="nb">require</span> <span class="s1">&#39;net/ssh&#39;</span>
<span class="no">Net</span><span class="o">::</span><span class="no">SSH</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="s2">&quot;myhost&quot;</span><span class="p">,</span> <span class="s2">&quot;username&quot;</span><span class="p">,</span> <span class="ss">:verbose</span> <span class="o">=&gt;</span> <span class="ss">:debug</span><span class="p">)</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="nb">p</span> <span class="n">x</span> <span class="p">}</span>
</pre></div>

<h3 id="_1">備考</h3>
<p>使ったのは以下のバージョン</p>
<ul>
<li>chef: 11.6.0</li>
<li>knife-solo: 0.3.0</li>
</ul>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>この挙動は<code>knife solo</code>コマンドに<code>-i</code>オプションを渡しても変わらなかった。&#160;<a href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://mojavy.com/blog</uri>
    </author>
    <title type="html"><![CDATA[ptraceを駆使してscreenifyっぽいことをするreptyrがすごい]]></title>
    <link rel="alternate" type="text/html" href="http://mojavy.com/blog/2013/07/12/reptyr/" />
    <id>http://mojavy.com/blog/2013/07/12/reptyr/</id>
    <updated>2013-07-12T19:15:50Z</updated>
    <published>2013-07-12T19:15:50Z</published>
    <category scheme="http://mojavy.com/blog" term="C" />
    <category scheme="http://mojavy.com/blog" term="linux" />
    <summary type="html"><![CDATA[ptraceを駆使してscreenifyっぽいことをするreptyrがすごい]]></summary>
    <content type="html" xml:base="http://mojavy.com/blog/2013/07/12/reptyr/"><![CDATA[<p>reptyrというおもしろいものをみつけたのでご紹介</p>
<h2 id="reptyr">reptyr とは</h2>
<p>reptyrとは"re-ptying"するためのプログラムで、起動中のプロセスを新しい別のターミナルにもってくることができます。
例えば、うっかりscreenやtmuxの外で起動してしまった長い時間のかかるバッチ処理を、起動したままscreenの中にもってくることができます。</p>
<p><a href="https://github.com/nelhage/reptyr">https://github.com/nelhage/reptyr</a> </p>
<h2 id="_1">使い方</h2>
<div class="pygments_borland"><pre><span class="nv">$ </span>reptyr PID
</pre></div>

<p>現在のターミナル内にもってきたいプロセスのpidを引数にします。
attach後は、そのプロセスの入出力は^Cや^Zも含めて新しいターミナル側を向きます。</p>
<h2 id="screenify">それscreenifyでできるよ</h2>
<p>screenifyと呼ばれるスクリプトが昔からあって、それはgdbつかって似たようなことをやってるらしいです。
でもreptyrならもっとうまくできます。</p>
<p>例えば従来のscreenifyには以下のような問題がありました。</p>
<ul>
<li>screenifyでattachしたプロセスは、元のターミナルから入力をうけつけてしまう</li>
<li>ncursesをつかってるプログラムをscreenifyすると、そのプログラムはwindowのリサイズがとれなくなる</li>
<li>screenifyした新しいターミナルでは^Cがきかない</li>
</ul>
<p>reptyrはこういった問題を全部解決できます。</p>
<h2 id="_2">移植性</h2>
<p>reptyrは対象プロセスを操作するのにptraceをつかっているのでLinuxに強く依存しており、Linuxだけをサポートしています。
SolarisやBSDに移植することも技術的には可能ですが、現状はプラットフォーム固有の部分を抽象化するようにはデザインされていないようです。</p>
<p>reptyrは現状ではi386, x86_64, ARMをサポートしています。他のアーキテクチャへの対応はarch以下に対応コードを追加すれば比較的容易です。</p>
<h2 id="ptrace_scope-on-ubuntu-maverick-and-up">ptrace_scope on Ubuntu Maverick and up</h2>
<p>Ubuntu Maverick以降ではptraceの機能がデフォルトで無効になっています。
以下コマンドで一時的に有効にできます。</p>
<div class="pygments_borland"><pre><span class="nv">$ </span><span class="nb">echo </span>0 &gt; /proc/sys/kernel/yama/ptrace_scope
</pre></div>

<p>rootで<code>/etc/sysctl.d/10-ptrace.conf</code>を編集すると永続的に変更できます。また<code>ptrace_scope</code>に関する詳細な説明もここに書いてあります。</p>
<h2 id="_3">どうやってるの？</h2>
<p>ソースを追ってみたところ以下のような処理をしているようです。</p>
<ol>
<li>reptyrプロセス側でptyをつくる</li>
<li>attach対象のプロセスのttyのtermios設定をptyにコピーする</li>
<li>ptraceで対象プロセスをattachしてレジスタ内容を一旦退避</li>
<li>attachしたプロセス側でmmapし、そこにreptyrプロセス側でつくったptyをコピー</li>
<li>attachしたプロセス側でコピーしたptyをopenし、setsid〜ioctlでそこに制御端末を割り当てる</li>
<li>attachしたプロセス側でdup2して入出力をttyに向ける</li>
<li>レジスタ内容を復元、後始末してptraceをdetach</li>
</ol>
<p>reptyrのキモは5の制御端末をptyに割り当てるところで、これをすることによって従来のscreenifyの問題が回避できます。</p>
<p>しかし、単に<code>ioctl</code>の<code>TIOCSCTTY</code>するだけではうまくいかないのでちょっとしたトリックが必要です。詳細は<a href="http://blog.nelhage.com/2011/02/changing-ctty/">http://blog.nelhage.com/2011/02/changing-ctty/</a> に解説があります。
reptyrの作者は自力でこの方法を思いついたそうですが、同様のテクニックは <a href="https://github.com/ThomasHabets/injcode">injcode</a> や<a href="http://www.ohloh.net/p/neercs">neercs</a> でも使用されているそうです。</p>
<h2 id="reptyr_1">reptyrってどう読むの？</h2>
<p><code>repeater</code>のように発音してもいいけど曖昧なので<code>re-P-T-Y-er</code> (たぶんリ・ピーティーワイアー)のように発音してもよいそうです。</p>
<h2 id="_4">制約</h2>
<ul>
<li>backgroundにしたときは前のターミナルでbgやfgを実行する必要があります。background制御はshellがやっているので、これを直すにはshell側に手をいれる必要があります。</li>
<li>現状では子プロセスがあるプロセスはattachできません</li>
</ul>
<h2 id="_5">類似のもの</h2>
<ul>
<li><a href="https://github.com/ThomasHabets/injcode">injcode</a> </li>
<li><a href="http://www.ohloh.net/p/neercs">neercs</a> </li>
</ul>
<h2 id="_6">参考</h2>
<ul>
<li><a href="http://blog.nelhage.com/2011/01/reptyr-attach-a-running-process-to-a-new-terminal/">http://blog.nelhage.com/2011/01/reptyr-attach-a-running-process-to-a-new-terminal/</a> </li>
<li><a href="http://blog.nelhage.com/2011/02/changing-ctty/">http://blog.nelhage.com/2011/02/changing-ctty/</a> </li>
<li><a href="http://blog.habets.pp.se/2009/03/Moving-a-process-to-another-terminal">http://blog.habets.pp.se/2009/03/Moving-a-process-to-another-terminal</a> </li>
</ul>
<h2 id="_7">まとめ</h2>
<p>reptyrは1000行くらいの小さなプログラムですが、なかなかおもしろいハックだと思うので興味がある方はソースを読んでみて下さい。</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://mojavy.com/blog</uri>
    </author>
    <title type="html"><![CDATA[C言語でtuple]]></title>
    <link rel="alternate" type="text/html" href="http://mojavy.com/blog/2013/07/10/c-tuple/" />
    <id>http://mojavy.com/blog/2013/07/10/c-tuple/</id>
    <updated>2013-07-10T21:02:39Z</updated>
    <published>2013-07-10T21:02:39Z</published>
    <category scheme="http://mojavy.com/blog" term="C" />
    <category scheme="http://mojavy.com/blog" term="programming" />
    <summary type="html"><![CDATA[C言語でtuple]]></summary>
    <content type="html" xml:base="http://mojavy.com/blog/2013/07/10/c-tuple/"><![CDATA[<p>Cをつかってるとtupleっぽいものがあれば便利なのに、と思うときが時々あります。</p>
<p>別にtupleなんてなくても</p>
<div class="pygments_borland"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
   <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
   <span class="kt">int</span> <span class="o">*</span><span class="n">i</span><span class="p">;</span>
<span class="p">}</span> <span class="n">tuple</span><span class="p">;</span>
</pre></div>

<p>のようにして構造体をつかえばいいのですが、必要になるたびにこれをするのはちょっとめんどくさいですよね。</p>
<p>というわけで色々試行錯誤してみたところ、以下のようにしてunionの配列にするというのがそこそこ便利だったので紹介します。</p>
<p>以下は使用例です。</p>
<div class="pygments_borland"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span> <span class="n">tuple_u</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">tuple_u</span> <span class="n">tuple</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">tuple</span> <span class="n">t</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span> <span class="p">.</span><span class="n">s</span> <span class="o">=</span> <span class="s">&quot;hoge&quot;</span> <span class="p">},</span> <span class="p">{</span> <span class="p">.</span><span class="n">i</span> <span class="o">=</span> <span class="mi">123</span> <span class="p">}</span> <span class="p">};</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s, %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">i</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>C99のdesignated initializerをつかえば初期化もまあそこそこ書きやすいし、型の組み合わせもある程度柔軟にできます。</p>
<p>C++ではなくあえてCをつかうような人の多くは独自のコンテナライブラリのようなものをもってると思いますが、上記のようなtupleがあれば便利な場面は結構あるのではないかと思います。</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://mojavy.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Quicklinks 6]]></title>
    <link rel="alternate" type="text/html" href="http://mojavy.com/blog/2013/06/15/quicklinks6/" />
    <id>http://mojavy.com/blog/2013/06/15/quicklinks6/</id>
    <updated>2013-06-15T23:20:27Z</updated>
    <published>2013-06-15T23:20:27Z</published>
    <category scheme="http://mojavy.com/blog" term="quicklinks" />
    <summary type="html"><![CDATA[Quicklinks 6]]></summary>
    <content type="html" xml:base="http://mojavy.com/blog/2013/06/15/quicklinks6/"><![CDATA[<p><img alt="leaf" src="/images/leaf.jpg" /> </p>
<p>最近道端の植物を観察するのがマイブームです。
写真は六本木ヒルズにあるミニ庭園っぽいとこに植えてあった草。名前はわからない。
おもしろい植物があってもなかなか名前を同定するところまで到達できないのがつらいところ。</p>
<h3 id="go">Go</h3>
<ul>
<li><a href="http://ukai-go-talks.appspot.com/2013/gocon.slide">http://ukai-go-talks.appspot.com/2013/gocon.slide</a> </li>
<li><a href="http://blogger.ukai.org/2013/04/go-conference-2013-spring.html">http://blogger.ukai.org/2013/04/go-conference-2013-spring.html</a> </li>
<li><a href="http://talks.golang.org/2012/splash.article">http://talks.golang.org/2012/splash.article</a></li>
<li><a href="http://golang.jp/">http://golang.jp/</a> </li>
<li><a href="http://d.hatena.ne.jp/Jxck/20130530/1369928762">http://d.hatena.ne.jp/Jxck/20130530/1369928762</a> </li>
</ul>
<p>最近まわりで評判がよくて久々試してみたら思いの外よかったので真面目にやってみようかという気になりました。
勝手なイメージでは、ErlangとCとJavascriptのいいとこ取りしてる感じ。</p>
<p>Race Detectorなんてものもあるらしい。すごい。</p>
<h3 id="trick-2013">TRICK 2013</h3>
<ul>
<li><a href="https://sites.google.com/site/trickcontest2013/home/ja">https://sites.google.com/site/trickcontest2013/home/ja</a> </li>
<li><a href="https://github.com/tric/trick2013">https://github.com/tric/trick2013</a> </li>
</ul>
<p>これに入賞するにはプログラミングスキルだけじゃなくてセンスと教養と変態性が必要だと感じました。</p>
<h2 id="_1">電王戦</h2>
<ul>
<li><a href="http://ex.nicovideo.jp/denousen2013/">http://ex.nicovideo.jp/denousen2013/</a> </li>
<li><a href="http://www.tanaka.ecc.u-tokyo.ac.jp/~ktanaka/denou2/">http://www.tanaka.ecc.u-tokyo.ac.jp/~ktanaka/denou2/</a> </li>
</ul>
<p>人同士が対戦してるのを見るのは別のおもしろさがあるので人間が負けたからといってどうということもないとは思いますが、
実際コンピュータが勝ってしまうとちょっと寂しくも感じてしまいますね。</p>
<p>ちなみに将棋の探索木データは一部公開されているようです。
今のところ使い道は特に思いうかびませんが、こういうものの存在を覚えておくとAIとかを書きたくなったときとかに参考にできるかも。</p>
<h3 id="ternjs">ternjs</h3>
<ul>
<li><a href="http://ternjs.net/">http://ternjs.net/</a> </li>
</ul>
<p>IDEでのJavaやC#みたいなインテリジェントなエディタサポートをJavascriptでもできるようにするためのものです。普通に便利ですね。</p>
<h3 id="xbox-one-ps4">Xbox One, PS4</h3>
<ul>
<li><a href="http://www.xbox.com/en-US/xboxone/meet-xbox-one">http://www.xbox.com/en-US/xboxone/meet-xbox-one</a> </li>
<li><a href="http://www.jp.playstation.com/ps4/">http://www.jp.playstation.com/ps4/</a> </li>
<li><a href="http://youtu.be/pGQXdEHc3LY">http://youtu.be/pGQXdEHc3LY</a> </li>
<li><a href="http://youtu.be/njfj6KwEAfg">http://youtu.be/njfj6KwEAfg</a> </li>
</ul>
<p>もはやぱっと見では実写と見分けがつかないです。</p>
<h3 id="haswell">Haswell</h3>
<ul>
<li><a href="http://www.intel.com/content/www/us/en/processors/core/4th-gen-core-family-desktop-vol-1-datasheet.html">http://www.intel.com/content/www/us/en/processors/core/4th-gen-core-family-desktop-vol-1-datasheet.html</a> </li>
<li><a href="http://ascii.jp/elem/000/000/726/726151/">http://ascii.jp/elem/000/000/726/726151/</a> </li>
</ul>
<p>何やらおもしろそうな新機能が導入されたようです。</p>
<h3 id="nsa">NSAのリークの話</h3>
<ul>
<li><a href="http://wired.jp/2013/06/11/nsa-leaker-outs-himself/">http://wired.jp/2013/06/11/nsa-leaker-outs-himself</a> </li>
</ul>
<p>一個人が天下のアンクル・サムさんに喧嘩を売るという映画のような展開で野次馬せずにはいられません。</p>]]></content>
  </entry>
</feed>
